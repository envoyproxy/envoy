// Copyright 2018 Google LLC
// Copyright Envoy Project Authors
// SPDX-License-Identifier: Apache-2.0

#include "source/common/jwt/verify.h"

#include "test/common/jwt/test_common.h"

#include "gtest/gtest.h"

namespace Envoy {
namespace JwtVerify {
namespace {

// SPELLCHECKER(off)
// Please see jwt_generator.py and jwk_generator.py under
// https://github.com/istio/proxy/tree/master/src/envoy/http/jwt_auth/tools
// for ES{256,384,512}-signed jwt token and public jwk generation, respectively.
// jwt_generator.py uses ES{256,384,512} private key file to generate JWT token.
// ES256 private key file can be generated by:
// $ openssl ecparam -genkey -name prime256v1 -noout -out private_key.pem
// ES384 private key file can be generated by:
// $ openssl ecparam -genkey -name secp384r1 -noout -out private_key.pem
// ES512 private key file can be generated by:
// $ openssl ecparam -genkey -name secp521r1 -noout -out private_key.pem
// jwk_generator.py uses ES{256.384,512} public key file to generate JWK.
// ES256, ES384 and ES512 public key files can be generated by:
// $ openssl ec -in private_key.pem -pubout -out public_key.pem

// ES256 private key:
// "-----BEGIN EC PRIVATE KEY-----"
// "MHcCAQEEIOyf96eKdFeSFYeHiM09vGAylz+/auaXKEr+fBZssFsJoAoGCCqGSM49"
// "AwEHoUQDQgAEEB54wykhS7YJFD6RYJNnwbWEz3cI7CF5bCDTXlrwI5n3ZsIFO8wV"
// "DyUptLYxuCNPdh+Zijoec8QTa2wCpZQnDw=="
// "-----END EC PRIVATE KEY-----"

// ES256 public key:
// "-----BEGIN PUBLIC KEY-----"
// "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEB54wykhS7YJFD6RYJNnwbWEz3cI"
// "7CF5bCDTXlrwI5n3ZsIFO8wVDyUptLYxuCNPdh+Zijoec8QTa2wCpZQnDw=="
// "-----END PUBLIC KEY-----"

// ES384 private key:
// "-----BEGIN EC PRIVATE KEY-----"
// "MIGkAgEBBDDqSPe2gvdUVMQcCxpr60rScFgjEQZeCYvZRq3oyY9mECVMK7nuRjLx"
// "blWjf6DH9E+gBwYFK4EEACKhZANiAATJjwNZzJaWuv3cVOuxwjlh3PY0Lt6Z+gpg"
// "cktfZ2vdxKB/DQa7ECS5DmcEwmZVXmACfnBXER+SwM5r/O9IccaR5glR+XzLXXBi"
// "Q6UWMG32k4LDn5GV9mA85reluZSq7Fk="
// "-----END EC PRIVATE KEY-----"

// ES384 public key:
// "-----BEGIN PUBLIC KEY-----"
// "MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEyY8DWcyWlrr93FTrscI5Ydz2NC7emfoK"
// "YHJLX2dr3cSgfw0GuxAkuQ5nBMJmVV5gAn5wVxEfksDOa/zvSHHGkeYJUfl8y11w"
// "YkOlFjBt9pOCw5+RlfZgPOa3pbmUquxZ"
// "-----END PUBLIC KEY-----"

// ES512 private key:
// "-----BEGIN EC PRIVATE KEY-----"
// "MIHcAgEBBEIBKlG7GPIoqQujJHwe21rnsZePySFyd45HPe3FeldgZQEHqcUiZgpb"
// "BgiuYMPHytEaohj1yC5gyOOsOfgsWY2qSsWgBwYFK4EEACOhgYkDgYYABAG4o4ns"
// "e68+7fv2Y/xOjqNDl3vQv/jAkg/jloqNeQE0Box/VqW1ozetmaq61P58CYqqsMem"
// "bGCoVHPydz0WjG3VQgAXFqWMIi6hUQDs8khoM8nl49e1nSGSKdPUH9tD3WZKEKJH"
// "/jdaGyfU/sbPfRYScu4mzVIZXPWhPiUhFRieLY58iQ=="
// "-----END EC PRIVATE KEY-----"

// ES512 public key:
// "-----BEGIN PUBLIC KEY-----"
// "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBuKOJ7HuvPu379mP8To6jQ5d70L/4"
// "wJIP45aKjXkBNAaMf1altaM3rZmqutT+fAmKqrDHpmxgqFRz8nc9Foxt1UIAFxal"
// "jCIuoVEA7PJIaDPJ5ePXtZ0hkinT1B/bQ91mShCiR/43Whsn1P7Gz30WEnLuJs1S"
// "GVz1oT4lIRUYni2OfIk="
// "-----END PUBLIC KEY-----"
// SPELLCHECKER(on)
const std::string PublicKeyJwkEC = R"(
{
  "keys": [
    {
      "kty": "EC",
      "crv": "P-256",
      "alg": "ES256",
      "kid": "abc",
      "x": "EB54wykhS7YJFD6RYJNnwbWEz3cI7CF5bCDTXlrwI5k",
      "y": "92bCBTvMFQ8lKbS2MbgjT3YfmYo6HnPEE2tsAqWUJw8"
    },
    {
      "kty": "EC",
      "crv": "P-256",
      "alg": "ES256",
      "kid": "xyz",
      "x": "EB54wykhS7YJFD6RYJNnwbWEz3cI7CF5bCDTXlrwI5k",
      "y": "92bCBTvMFQ8lKbS2MbgjT3YfmYo6HnPEE2tsAqWUJw8"
    },
    {
      "kty": "EC",
      "crv": "P-384",
      "alg": "ES384",
      "kid": "es384",
      "x": "yY8DWcyWlrr93FTrscI5Ydz2NC7emfoKYHJLX2dr3cSgfw0GuxAkuQ5nBMJmVV5g",
      "y": "An5wVxEfksDOa_zvSHHGkeYJUfl8y11wYkOlFjBt9pOCw5-RlfZgPOa3pbmUquxZ"
    },
    {
      "kty": "EC",
      "crv": "P-521",
      "alg": "ES512",
      "kid": "es512",
      "x": "Abijiex7rz7t-_Zj_E6Oo0OXe9C_-MCSD-OWio15ATQGjH9WpbWjN62ZqrrU_nwJiqqwx6ZsYKhUc_J3PRaMbdVC",
      "y": "FxaljCIuoVEA7PJIaDPJ5ePXtZ0hkinT1B_bQ91mShCiR_43Whsn1P7Gz30WEnLuJs1SGVz1oT4lIRUYni2OfIk"
    }
  ]
}
)";

// SPELLCHECKER(off)
// "{"kid":"abc"}"
// SPELLCHECKER(on)
const std::string JwtES256Text =
    "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYyJ9.eyJpc3MiOiI2Mj"
    "g2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvc"
    "GVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzdWIiOiI2Mjg2NDU3NDE4ODEtbm9hYml1"
    "MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3V"
    "udC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmNvbS9teWFwaSJ9.T2KAwChqg"
    "o2ZSXyLh3IcMBQNSeRZRe5Z-MUDl-s-F99XGoyutqA6lq8bKZ6vmjZAlpVG8AGRZW9J"
    "Gp9lq3cbEw";

const std::string JwtTextEC = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYyJ9.eyJpc3MiOiI2Mj"
                              "g2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvc"
                              "GVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzdWIiOiI2Mjg2NDU3NDE4ODEtbm9hYml1"
                              "MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3V"
                              "udC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmNvbS9teWFwaSJ9.T2KAwChqg"
                              "o2ZSXyLh3IcMBQNSeRZRe5Z-MUDl-s-F99XGoyutqA6lq8bKZ6vmjZAlpVG8AGRZW9J"
                              "Gp9lq3cbEw";

// SPELLCHECKER(off)
// "{"kid":"es384"}"
// SPELLCHECKER(on)
const std::string JwtES384Text =
    "eyJhbGciOiJFUzM4NCIsInR5cCI6IkpXVCIsImtpZCI6ImVzMzg0In0.eyJpc3MiOi"
    "I2Mjg2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZ"
    "GV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzdWIiOiI2Mjg2NDU3NDE4"
    "ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmd"
    "zZXJ2aWNlYWNjb3VudC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmNvbS"
    "9teWFwaSJ9.aKFxrqV4_rg1Zf2DamTU0D76hOq9-FYu-LNmpGPthjJKv31mOZ4t"
    "J40x2FVVJx5d8lntg3bsy1IN0z9C7MD_k10Y7Gea1YB7Jyi-DR68U5krJzzwKmD"
    "9ap1J7tb2UrzT";

// SPELLCHECKER(off)
// "{"kid":"es512"}"
// SPELLCHECKER(on)
const std::string JwtES512Text =
    "eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCIsImtpZCI6ImVzNTEyIn0.eyJpc3MiOi"
    "I2Mjg2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZ"
    "GV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzdWIiOiI2Mjg2NDU3NDE4"
    "ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmd"
    "zZXJ2aWNlYWNjb3VudC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmNvbS"
    "9teWFwaSJ9.ATSReP9zpba6PRJZmlIEA78Ft-FZS1m_SpFLqfiNQNexaDaTmmVr"
    "IqD9X-krPxk0c8KSBeMlU-QLOsbh37coamruAPKoAODYWA-QKUN2a_xem8WrudK"
    "VXWsmQlZDOJA0lQWI-YGMEPrDr17mljMhZwSGbVVST9l-nZiMXyMK0z8hR9Mn";

// SPELLCHECKER(off)
// "{"kid":"abcdef"}"
// SPELLCHECKER(on)
const std::string JwtTextWithNonExistKidEC =
    "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiY2RlZiJ9.eyJpc3MiOi"
    "I2Mjg2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZ"
    "GV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzdWIiOiI2Mjg2NDU3NDE4"
    "ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmd"
    "zZXJ2aWNlYWNjb3VudC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmNvbS"
    "9teWFwaSJ9.rWSoOV5j7HxHc4yVgZEZYUSgY7AUarG3HxdfPON1mw6II_pNUsc8"
    "_sVf7Yv2-jeVhmf8BtR99wnOwEDhVYrVpQ";

const std::string JwtTextECNoKid =
    "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI2Mjg2NDU3NDE4ODEtbm"
    "9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmdzZXJ2a"
    "WNlYWNjb3VudC5jb20iLCJzdWIiOiI2Mjg2NDU3NDE4ODEtbm9hYml1MjNmNWE4"
    "bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5"
    "jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmNvbS9teWFwaSJ9.zlFcET8Fi"
    "OYcKe30A7qOD4TIBvtb9zIVhDcM8pievKs1Te-UOBcklQxhwXMnRSSEBY4P0pfZ"
    "qWJT_V5IVrKrdQ";

class VerifyJwkECTest : public testing::Test {
protected:
  void SetUp() {
    jwks_ = Jwks::createFrom(PublicKeyJwkEC, Jwks::Type::JWKS);
    EXPECT_EQ(jwks_->getStatus(), Status::Ok);
  }

  JwksPtr jwks_;
};

TEST_F(VerifyJwkECTest, KidOK) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextEC), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_), Status::Ok);

  fuzzJwtSignature(jwt, [this](const Jwt& jwt) {
    EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
  });
}

TEST_F(VerifyJwkECTest, KidES384OK) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES384Text), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_), Status::Ok);

  fuzzJwtSignature(jwt, [this](const Jwt& jwt) {
    EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
  });
}

TEST_F(VerifyJwkECTest, KidES512OK) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES512Text), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_), Status::Ok);

  fuzzJwtSignature(jwt, [this](const Jwt& jwt) {
    EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
  });
}

TEST_F(VerifyJwkECTest, NoKidOK) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextECNoKid), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_), Status::Ok);

  fuzzJwtSignature(jwt, [this](const Jwt& jwt) {
    EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
  });
}

TEST_F(VerifyJwkECTest, NonExistKidFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextWithNonExistKidEC), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwksKidAlgMismatch);
}

// Test EC signature verification with empty signature.
// This exercises the `BN_bin2bn` and `ECDSA_SIG_set0` code paths with zero-length data.
TEST_F(VerifyJwkECTest, EmptySignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextEC), Status::Ok);
  // Clear the signature to make it empty.
  jwt.signature_.clear();
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test EC signature verification with a very short signature (1 byte).
// This tests edge cases in signature parsing where signature_len / 2 = 0.
TEST_F(VerifyJwkECTest, VeryShortSignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextEC), Status::Ok);
  // Set signature to a single byte.
  jwt.signature_ = "x";
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test EC signature verification with a 2-byte signature.
// This tests the minimum case where both r and s get 1 byte each.
TEST_F(VerifyJwkECTest, TwoByteSignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextEC), Status::Ok);
  // Set signature to two bytes.
  jwt.signature_ = "xy";
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test EC signature verification with odd-length signature.
// This ensures proper handling when signature_len is not evenly divisible by 2.
TEST_F(VerifyJwkECTest, OddLengthSignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextEC), Status::Ok);
  // Set signature to 3 bytes (odd length).
  jwt.signature_ = "xyz";
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

TEST_F(VerifyJwkECTest, PubkeyNoAlgOK) {
  // Remove "alg" claim from public key.
  std::string alg_claim = R"("alg": "ES256",)";
  std::string pubkey_no_alg = PublicKeyJwkEC;
  std::size_t alg_pos = pubkey_no_alg.find(alg_claim);
  while (alg_pos != std::string::npos) {
    pubkey_no_alg.erase(alg_pos, alg_claim.length());
    alg_pos = pubkey_no_alg.find(alg_claim);
  }

  jwks_ = Jwks::createFrom(pubkey_no_alg, Jwks::Type::JWKS);
  EXPECT_EQ(jwks_->getStatus(), Status::Ok);

  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES256Text), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::Ok);
}

TEST_F(VerifyJwkECTest, PubkeyNoKidOK) {
  // Remove "kid" claim from public key.
  std::string kid_claim1 = R"("kid": "abc",)";
  std::string kid_claim2 = R"("kid": "xyz",)";
  std::string pubkey_no_kid = PublicKeyJwkEC;
  std::size_t kid_pos = pubkey_no_kid.find(kid_claim1);
  pubkey_no_kid.erase(kid_pos, kid_claim1.length());
  kid_pos = pubkey_no_kid.find(kid_claim2);
  pubkey_no_kid.erase(kid_pos, kid_claim2.length());

  jwks_ = Jwks::createFrom(pubkey_no_kid, Jwks::Type::JWKS);
  EXPECT_EQ(jwks_->getStatus(), Status::Ok);

  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES256Text), Status::Ok);
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::Ok);
}

// Test ES384 signature verification with empty signature.
TEST_F(VerifyJwkECTest, ES384EmptySignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES384Text), Status::Ok);
  jwt.signature_.clear();
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test ES384 signature verification with very short signature.
TEST_F(VerifyJwkECTest, ES384VeryShortSignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES384Text), Status::Ok);
  jwt.signature_ = "x";
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test ES512 signature verification with empty signature.
TEST_F(VerifyJwkECTest, ES512EmptySignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES512Text), Status::Ok);
  jwt.signature_.clear();
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test ES512 signature verification with very short signature.
TEST_F(VerifyJwkECTest, ES512VeryShortSignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtES512Text), Status::Ok);
  jwt.signature_ = "x";
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

// Test EC signature verification with signature half the expected length.
// For ES256, the signature should be 64 bytes (32 for r, 32 for s).
// This tests with 32 bytes to ensure proper handling of undersized signatures.
TEST_F(VerifyJwkECTest, HalfLengthSignatureFail) {
  Jwt jwt;
  EXPECT_EQ(jwt.parseFromString(JwtTextEC), Status::Ok);
  // Truncate to half the expected signature length.
  if (jwt.signature_.size() > 32) {
    jwt.signature_ = jwt.signature_.substr(0, 32);
  }
  EXPECT_EQ(verifyJwt(jwt, *jwks_, 1), Status::JwtVerificationFail);
}

} // namespace
} // namespace JwtVerify
} // namespace Envoy
