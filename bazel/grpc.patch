diff --git a/BUILD b/BUILD
index 9e067aa29e..089a447ec4 100644
--- a/BUILD
+++ b/BUILD
@@ -34,7 +34,7 @@ package(
     default_visibility = ["//visibility:public"],
     features = [
         "-parse_headers",
-        "layering_check",
+        "-layering_check",
     ],
 )
 
diff --git a/bazel/grpc_build_system.bzl b/bazel/grpc_build_system.bzl
index a3b8923b6e..f4a2ed3f13 100644
--- a/bazel/grpc_build_system.bzl
+++ b/bazel/grpc_build_system.bzl
@@ -27,7 +27,6 @@
 Contains macros used throughout the repo.
 """
 
-load("@build_bazel_apple_support//rules:universal_binary.bzl", "universal_binary")
 load("@build_bazel_rules_apple//apple:ios.bzl", "ios_unit_test")
 load("@build_bazel_rules_apple//apple/testing/default_runner:ios_test_runner.bzl", "ios_test_runner")
 load("@com_google_protobuf//bazel:cc_proto_library.bzl", "cc_proto_library")
@@ -195,16 +194,11 @@ def grpc_proto_plugin(name, srcs = [], deps = []):
         srcs = srcs,
         deps = deps,
     )
-    universal_binary(
-        name = name + "_universal",
-        binary = name + "_native",
-    )
 
     # In order to avoid warnings from Bazel, names of the rule and its output file must differ.
     native.genrule(
         name = name,
         srcs = select({
-            "@platforms//os:macos": [name + "_universal"],
             "//conditions:default": [name + "_native"],
         }),
         outs = [name + "_binary"],
diff --git a/src/core/BUILD b/src/core/BUILD
index 0a8eebafb9..6d4f158719 100644
--- a/src/core/BUILD
+++ b/src/core/BUILD
@@ -29,7 +29,7 @@ licenses(["reciprocal"])
 package(
     default_visibility = ["//:__subpackages__"],
     features = [
-        "layering_check",
+        "-layering_check",
     ],
 )
 
diff --git a/src/core/lib/promise/detail/promise_factory.h b/src/core/lib/promise/detail/promise_factory.h
index 3fb5d68146..583a2f9553 100644
--- a/src/core/lib/promise/detail/promise_factory.h
+++ b/src/core/lib/promise/detail/promise_factory.h
@@ -125,17 +125,16 @@ struct OnceToken {};
 // Promote a callable(A) -> T | Poll<T> to a PromiseFactory(A) -> Promise<T> by
 // capturing A.
 template <typename Token, typename A, typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION
-    absl::enable_if_t<!IsVoidCallable<ResultOf<F(A)>>::value,
-                      PromiseLike<Curried<RemoveCVRef<F>, A>>>
-    PromiseFactoryImpl(Token, F&& f, A&& arg) {
+absl::enable_if_t<!IsVoidCallable<ResultOf<F(A)>>::value,
+                  PromiseLike<Curried<RemoveCVRef<F>, A>>>
+PromiseFactoryImpl(Token, F&& f, A&& arg) {
   return Curried<RemoveCVRef<F>, A>(std::forward<F>(f), std::forward<A>(arg));
 }
 
 // Promote a callable() -> T|Poll<T> to a PromiseFactory(A) -> Promise<T>
 // by dropping the argument passed to the factory.
 template <typename A, typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline absl::enable_if_t<
+inline absl::enable_if_t<
     !IsVoidCallable<ResultOf<F()>>::value, PromiseLike<RemoveCVRef<F>>>
 PromiseFactoryImpl(OnceToken, F f, A&&) {
   return PromiseLike<F>(std::move(f));
@@ -143,7 +142,7 @@ PromiseFactoryImpl(OnceToken, F f, A&&) {
 
 // Promote a callable() -> Poll<T> to a PromiseFactory() -> Promise<T>
 template <typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline absl::enable_if_t<
+inline absl::enable_if_t<
     !IsVoidCallable<ResultOf<F()>>::value &&
         PollTraits<ResultOf<F()>>::is_poll(),
     PromiseLike<RemoveCVRef<F>>>
@@ -153,7 +152,7 @@ PromiseFactoryImpl(OnceToken, F f) {
 
 // Promote a callable() -> T to a PromiseFactory() -> Immediate<T>
 template <typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline auto PromiseFactoryImpl(
+inline auto PromiseFactoryImpl(
     std::enable_if_t<!IsVoidCallable<ResultOf<F()>>::value &&
                          !PollTraits<ResultOf<F()>>::is_poll() &&
                          !std::is_same_v<ResultOf<F()>, void>,
@@ -163,7 +162,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline auto PromiseFactoryImpl(
   return PromiseLike<decltype(f2)>(std::move(f2));
 }
 template <typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline auto PromiseFactoryImpl(
+inline auto PromiseFactoryImpl(
     std::enable_if_t<!IsVoidCallable<ResultOf<F()>>::value &&
                          !PollTraits<ResultOf<F()>>::is_poll() &&
                          std::is_same_v<ResultOf<F()>, void>,
@@ -176,7 +175,7 @@ GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline auto PromiseFactoryImpl(
 
 // Given a callable(A) -> Promise<T>, name it a PromiseFactory and use it.
 template <typename Token, typename A, typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline absl::enable_if_t<
+inline absl::enable_if_t<
     IsVoidCallable<ResultOf<F(A)>>::value,
     PromiseLike<decltype(std::declval<F>()(std::declval<A>()))>>
 PromiseFactoryImpl(Token, F&& f, A&& arg) {
@@ -185,7 +184,7 @@ PromiseFactoryImpl(Token, F&& f, A&& arg) {
 
 // Given a callable(A) -> Promise<T>, name it a PromiseFactory and use it.
 template <typename Token, typename A, typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION inline absl::enable_if_t<
+inline absl::enable_if_t<
     IsVoidCallable<ResultOf<F(A)>>::value,
     PromiseLike<decltype(std::declval<F>()(std::declval<A>()))>>
 PromiseFactoryImpl(Token, F& f, A&& arg) {
@@ -195,19 +194,17 @@ PromiseFactoryImpl(Token, F& f, A&& arg) {
 // Given a callable() -> Promise<T>, promote it to a
 // PromiseFactory(A) -> Promise<T> by dropping the first argument.
 template <typename Token, typename A, typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION
-    absl::enable_if_t<IsVoidCallable<ResultOf<F()>>::value,
-                      PromiseLike<decltype(std::declval<F>()())>>
-    PromiseFactoryImpl(Token, F&& f, A&&) {
+absl::enable_if_t<IsVoidCallable<ResultOf<F()>>::value,
+                  PromiseLike<decltype(std::declval<F>()())>>
+PromiseFactoryImpl(Token, F&& f, A&&) {
   return f();
 }
 
 // Given a callable() -> Promise<T>, name it a PromiseFactory and use it.
 template <typename Token, typename F>
-GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION
-    absl::enable_if_t<IsVoidCallable<ResultOf<F()>>::value,
-                      PromiseLike<decltype(std::declval<F>()())>>
-    PromiseFactoryImpl(Token, F&& f) {
+absl::enable_if_t<IsVoidCallable<ResultOf<F()>>::value,
+                  PromiseLike<decltype(std::declval<F>()())>>
+PromiseFactoryImpl(Token, F&& f) {
   return f();
 }
 
@@ -225,10 +222,10 @@ class OncePromiseFactory {
                                               std::declval<A>()));
   using UnderlyingFactory = F;
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION explicit OncePromiseFactory(F f)
+  explicit OncePromiseFactory(F f)
       : f_(std::move(f)) {}
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Promise Make(Arg&& a) {
+  Promise Make(Arg&& a) {
     return PromiseFactoryImpl(OnceToken{}, std::move(f_), std::forward<Arg>(a));
   }
 };
@@ -243,10 +240,10 @@ class OncePromiseFactory<void, F> {
   using Promise = decltype(PromiseFactoryImpl(OnceToken{}, std::move(f_)));
   using UnderlyingFactory = F;
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION explicit OncePromiseFactory(F f)
+  explicit OncePromiseFactory(F f)
       : f_(std::move(f)) {}
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Promise Make() {
+  Promise Make() {
     return PromiseFactoryImpl(OnceToken{}, std::move(f_));
   }
 };
@@ -265,13 +262,13 @@ class RepeatedPromiseFactory {
   using Promise =
       decltype(PromiseFactoryImpl(RepeatableToken{}, f_, std::declval<A>()));
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION explicit RepeatedPromiseFactory(F f)
+  explicit RepeatedPromiseFactory(F f)
       : f_(std::move(f)) {}
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Promise Make(Arg&& a) const {
+  Promise Make(Arg&& a) const {
     return PromiseFactoryImpl(RepeatableToken{}, f_, std::forward<Arg>(a));
   }
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Promise Make(Arg&& a) {
+  Promise Make(Arg&& a) {
     return PromiseFactoryImpl(RepeatableToken{}, f_, std::forward<Arg>(a));
   }
   template <typename U>
@@ -293,13 +290,13 @@ class RepeatedPromiseFactory<void, F> {
   using Arg = void;
   using Promise = decltype(PromiseFactoryImpl(RepeatableToken{}, f_));
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION explicit RepeatedPromiseFactory(F f)
+  explicit RepeatedPromiseFactory(F f)
       : f_(std::move(f)) {}
 
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Promise Make() const {
+  Promise Make() const {
     return PromiseFactoryImpl(RepeatableToken{}, f_);
   }
-  GPR_ATTRIBUTE_ALWAYS_INLINE_FUNCTION Promise Make() {
+  Promise Make() {
     return PromiseFactoryImpl(RepeatableToken{}, f_);
   }
 };
diff --git a/src/proto/grpc/health/v1/BUILD b/src/proto/grpc/health/v1/BUILD
index f6165e0392..374653516a 100644
--- a/src/proto/grpc/health/v1/BUILD
+++ b/src/proto/grpc/health/v1/BUILD
@@ -44,3 +44,10 @@ filegroup(
         "health.proto",
     ],
 )
+
+# This alias is required by Envoy's build
+alias(
+    name = "_health_proto_only",
+    actual = ":health_proto",
+    visibility = ["//visibility:public"],
+)
diff --git a/third_party/BUILD b/third_party/BUILD
index 13a4714d4b..8664e99ffc 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -33,19 +33,13 @@ config_setting(
 
 alias(
     name = "libssl",
-    actual = select({
-        ":grpc_use_openssl_setting": "@openssl//:ssl",
-        "//conditions:default": "@boringssl//:ssl",
-    }),
+    actual = "@envoy//bazel:boringssl",
     tags = ["manual"],
 )
 
 alias(
     name = "libcrypto",
-    actual = select({
-        ":grpc_use_openssl_setting": "@openssl//:crypto",
-        "//conditions:default": "@boringssl//:crypto",
-    }),
+    actual = "@envoy//bazel:boringcrypto",
     tags = ["manual"],
 )
 
@@ -82,7 +76,7 @@ alias(
 
 alias(
     name = "cares",
-    actual = "@com_github_cares_cares//:ares",
+    actual = "@com_github_c_ares_c_ares//:ares",
     tags = ["manual"],
 )
 
