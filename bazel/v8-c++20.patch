diff --git a/src/base/numerics/safe_conversions_impl.h b/src/base/numerics/safe_conversions_impl.h
index cfe21e441e9..34c0ae98133 100644
--- a/src/base/numerics/safe_conversions_impl.h
+++ b/src/base/numerics/safe_conversions_impl.h
@@ -353,7 +353,7 @@ INTEGER_FOR_DIGITS_AND_SIGN(uint64_t);
 
 template <size_t Size, bool IsSigned>
 using IntegerForDigitsAndSign =
-    IntegerForDigitsAndSignImpl<Size, IsSigned>::type;
+    typename IntegerForDigitsAndSignImpl<Size, IsSigned>::type;
 
 // WARNING: We have no IntegerForSizeAndSign<16, *>. If we ever add one to
 // support 128-bit math, then the ArithmeticPromotion template below will need
@@ -414,7 +414,7 @@ struct BigEnoughPromotionImpl<Lhs, Rhs, true, false> {
 };
 
 template <typename Lhs, typename Rhs>
-using BigEnoughPromotion = BigEnoughPromotionImpl<Lhs, Rhs>::type;
+using BigEnoughPromotion = typename BigEnoughPromotionImpl<Lhs, Rhs>::type;
 
 template <typename Lhs, typename Rhs>
 inline constexpr bool kIsBigEnoughPromotionContained =
@@ -456,7 +456,7 @@ struct FastIntegerArithmeticPromotionImpl<Lhs, Rhs> {
 
 template <typename Lhs, typename Rhs>
 using FastIntegerArithmeticPromotion =
-    FastIntegerArithmeticPromotionImpl<Lhs, Rhs>::type;
+    typename FastIntegerArithmeticPromotionImpl<Lhs, Rhs>::type;
 
 template <typename Lhs, typename Rhs>
 inline constexpr bool kIsFastIntegerArithmeticPromotionContained =
@@ -470,7 +470,7 @@ struct ArithmeticOrIntegralConstant {
 template <typename T>
   requires IntegralConstantLike<T>
 struct ArithmeticOrIntegralConstant<T> {
-  using type = T::value_type;
+  using type = typename T::value_type;
 };
 
 // Extracts the underlying type from an enum.
@@ -531,7 +531,7 @@ struct UnderlyingTypeImpl<StrictNumeric<T>> {
   using type = T;
 };
 template <typename T>
-using UnderlyingType = UnderlyingTypeImpl<T>::type;
+using UnderlyingType = typename UnderlyingTypeImpl<T>::type;
 
 template <typename T>
 inline constexpr bool kIsNumeric = std::is_arithmetic_v<UnderlyingType<T>>;
