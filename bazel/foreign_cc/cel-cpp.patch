diff --git a/common/internal/byte_string.cc b/common/internal/byte_string.cc
index e01c797f8..12345678a 100644
--- a/common/internal/byte_string.cc
+++ b/common/internal/byte_string.cc
@@ -104,6 +104,13 @@
 
 ByteString::ByteString(Allocator<> allocator, absl::string_view string) {
   ABSL_DCHECK_LE(string.size(), max_size());
+
+  // Check for null data pointer in the string_view
+  if (string.data() == nullptr) {
+    // Handle null data by creating an empty ByteString
+    SetSmallEmpty(allocator.arena());
+    return;
+  }
   auto* arena = allocator.arena();
   if (string.size() <= kSmallByteStringCapacity) {
     SetSmall(arena, string);
diff --git a/common/typeinfo.h b/common/typeinfo.h
index 06a03c13d..9f5d77980 100644
--- a/common/typeinfo.h
+++ b/common/typeinfo.h
@@ -80,7 +80,7 @@
     std::conjunction_v<common_internal::HasNativeTypeTraitsId<T>,
                        std::negation<common_internal::HasCelTypeId<T>>>,
     TypeInfo>
-TypeId(const T& t) {
+TypeId(const T& t [[maybe_unused]]) {
   return NativeTypeTraits<absl::remove_cvref_t<T>>::Id(t);
 }
 
@@ -90,7 +90,7 @@
                        std::negation<common_internal::HasCelTypeId<T>>,
                        std::is_final<T>>,
     TypeInfo>
-TypeId(const T& t) {
+TypeId(const T& t [[maybe_unused]]) {
   return cel::TypeId<absl::remove_cvref_t<T>>();
 }
 
@@ -99,7 +99,7 @@
     std::conjunction_v<std::negation<common_internal::HasNativeTypeTraitsId<T>>,
                        common_internal::HasCelTypeId<T>>,
     TypeInfo>
-TypeId(const T& t) {
+TypeId(const T& t [[maybe_unused]]) {
   return CelTypeId(t);
 }
 
diff --git a/common/value.h b/common/value.h
index abcdef123..987654fed 100644
--- a/common/value.h
+++ b/common/value.h
@@ -2794,7 +2794,7 @@
     const google::protobuf::DescriptorPool* absl_nonnull descriptor_pool,
     google::protobuf::MessageFactory* absl_nonnull message_factory,
     google::protobuf::Arena* absl_nonnull arena) const {
-  ABSL_DCHECK_GT(qualifiers.size(), 0);
+  ABSL_DCHECK_GT(static_cast<int>(qualifiers.size()), 0);
   ABSL_DCHECK(descriptor_pool != nullptr);
   ABSL_DCHECK(message_factory != nullptr);
   ABSL_DCHECK(arena != nullptr);
diff --git a/internal/json.cc b/internal/json.cc
index abcdef123..123456789 100644
--- a/internal/json.cc
+++ b/internal/json.cc
@@ -302,7 +302,7 @@
         SetStringValue(result, TimeUtil::ToString(timestamp));
       } break;
       case Descriptor::WELLKNOWNTYPE_VALUE: {
-        absl::Cord serialized;
+        std::string serialized;
         if (!message.SerializePartialToString(&serialized)) {
           return absl::UnknownError(
               "failed to serialize message google.protobuf.Value");
@@ -313,7 +313,7 @@
         }
       } break;
       case Descriptor::WELLKNOWNTYPE_LISTVALUE: {
-        absl::Cord serialized;
+        std::string serialized;
         if (!message.SerializePartialToString(&serialized)) {
           return absl::UnknownError(
               "failed to serialize message google.protobuf.ListValue");
@@ -324,7 +324,7 @@
         }
       } break;
       case Descriptor::WELLKNOWNTYPE_STRUCT: {
-        absl::Cord serialized;
+        std::string serialized;
         if (!message.SerializePartialToString(&serialized)) {
           return absl::UnknownError(
               "failed to serialize message google.protobuf.Struct");
diff --git a/internal/well_known_types.cc b/internal/well_known_types.cc
index abcdef123..123456789 100644
--- a/internal/well_known_types.cc
+++ b/internal/well_known_types.cc
@@ -1974,7 +1974,7 @@
                                       return unpacked->ParseFromString(string);
                                     },
                                     [&](const absl::Cord& cord) -> bool {
-                                      return unpacked->ParseFromString(cord);
+                                      return unpacked->ParseFromString(static_cast<std::string>(cord));
                                     }),
                                 AsVariant(value));
     if (!ok) {
