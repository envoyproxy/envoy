diff --git a/bazel/cel_proto_transitive_descriptor_set.bzl b/bazel/cel_proto_transitive_descriptor_set.bzl
index e65e0b4a..0e143480 100644
--- a/bazel/cel_proto_transitive_descriptor_set.bzl
+++ b/bazel/cel_proto_transitive_descriptor_set.bzl
@@ -21,15 +21,33 @@ load("@com_google_protobuf//bazel/common:proto_info.bzl", "ProtoInfo")
 def _cel_proto_transitive_descriptor_set(ctx):
     output = ctx.actions.declare_file(ctx.attr.name + ".binarypb")
     transitive_descriptor_sets = depset(transitive = [dep[ProtoInfo].transitive_descriptor_sets for dep in ctx.attr.deps])
-    args = ctx.actions.args()
-    args.use_param_file(param_file_arg = "%s", use_always = True)
-    args.add_all(transitive_descriptor_sets)
+
+    # Generate script to concatenate files listed in a parameter file into an output file.
+    script = """
+set -euo pipefail
+PARAMS_FILE="$1"
+OUTPUT_FILE="$2"
+if [ ! -f "$PARAMS_FILE" ]; then
+    echo "Error: Parameter file not found at $PARAMS_FILE" >&2
+    exit 1
+fi
+exec > "$OUTPUT_FILE"
+while IFS= read -r file_to_cat || [[ -n "$file_to_cat" ]]; do
+    if [ -f "$file_to_cat" ]; then
+        cat "$file_to_cat"
+    fi
+done < "$PARAMS_FILE"
+"""
+
+    param_file_args = ctx.actions.args()
+    param_file_args.use_param_file(param_file_arg = "%s", use_always = True)
+    param_file_args.add_all(transitive_descriptor_sets)
     ctx.actions.run_shell(
         outputs = [output],
         inputs = transitive_descriptor_sets,
         progress_message = "Joining descriptors.",
-        command = ("< \"$1\" xargs cat >{output}".format(output = output.path)),
-        arguments = [args],
+        command=script,
+        arguments=[param_file_args, output.path],
     )
     return DefaultInfo(
         files = depset([output]),
diff --git a/common/internal/byte_string.cc b/common/internal/byte_string.cc
index b9f47922..9d096424 100644
--- a/common/internal/byte_string.cc
+++ b/common/internal/byte_string.cc
@@ -104,6 +104,13 @@ ByteString ByteString::Concat(const ByteString& lhs, const ByteString& rhs,
 
 ByteString::ByteString(Allocator<> allocator, absl::string_view string) {
   ABSL_DCHECK_LE(string.size(), max_size());
+
+  // Check for null data pointer in the string_view
+  if (string.data() == nullptr) {
+    // Handle null data by creating an empty ByteString
+    SetSmallEmpty(allocator.arena());
+    return;
+  }
   auto* arena = allocator.arena();
   if (string.size() <= kSmallByteStringCapacity) {
     SetSmall(arena, string);
diff --git a/common/typeinfo.h b/common/typeinfo.h
index 6c0a1c42..6a284790 100644
--- a/common/typeinfo.h
+++ b/common/typeinfo.h
@@ -80,7 +80,7 @@ std::enable_if_t<
     std::conjunction_v<common_internal::HasNativeTypeTraitsId<T>,
                        std::negation<common_internal::HasCelTypeId<T>>>,
     TypeInfo>
-TypeId(const T& t) {
+TypeId(const T& t [[maybe_unused]]) {
   return NativeTypeTraits<absl::remove_cvref_t<T>>::Id(t);
 }
 
@@ -90,7 +90,7 @@ std::enable_if_t<
                        std::negation<common_internal::HasCelTypeId<T>>,
                        std::is_final<T>>,
     TypeInfo>
-TypeId(const T& t) {
+TypeId(const T& t [[maybe_unused]]) {
   return cel::TypeId<absl::remove_cvref_t<T>>();
 }
 
@@ -99,7 +99,7 @@ std::enable_if_t<
     std::conjunction_v<std::negation<common_internal::HasNativeTypeTraitsId<T>>,
                        common_internal::HasCelTypeId<T>>,
     TypeInfo>
-TypeId(const T& t) {
+TypeId(const T& t [[maybe_unused]]) {
   return CelTypeId(t);
 }
 
diff --git a/common/value.h b/common/value.h
index 06225796..18f56e59 100644
--- a/common/value.h
+++ b/common/value.h
@@ -2794,7 +2794,7 @@ absl::StatusOr<std::pair<Value, int>> StructValueMixin<Base>::Qualify(
     const google::protobuf::DescriptorPool* absl_nonnull descriptor_pool,
     google::protobuf::MessageFactory* absl_nonnull message_factory,
     google::protobuf::Arena* absl_nonnull arena) const {
-  ABSL_DCHECK_GT(qualifiers.size(), 0);
+  ABSL_DCHECK_GT(static_cast<int>(qualifiers.size()), 0);
   ABSL_DCHECK(descriptor_pool != nullptr);
   ABSL_DCHECK(message_factory != nullptr);
   ABSL_DCHECK(arena != nullptr);
