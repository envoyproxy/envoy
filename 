[1mdiff --git a/mobile/library/common/internal_engine.cc b/mobile/library/common/internal_engine.cc[m
[1mindex 6a1951c767..be959e94ef 100644[m
[1m--- a/mobile/library/common/internal_engine.cc[m
[1m+++ b/mobile/library/common/internal_engine.cc[m
[36m@@ -1,5 +1,6 @@[m
 #include "library/common/internal_engine.h"[m
 [m
[32m+[m[32m#include <filesystem>[m
 #include <sys/resource.h>[m
 [m
 #include "source/common/api/os_sys_calls_impl.h"[m
[36m@@ -227,6 +228,7 @@[m [menvoy_status_t InternalEngine::main(std::shared_ptr<OptionsImplBase> options) {[m
                     // The default network has changed to a different one.[m
                     return;[m
                   }[m
[32m+[m[32m                  ENVOY_LOG_MISC(trace, "Default network state has been changed. Current net configuration key {}", current_configuration_key);[m
                   resetHttpPropertiesAndDrainHosts(probeAndGetLocalAddr(AF_INET6) != nullptr);[m
                   if (!disable_dns_refresh_on_network_change_) {[m
                     // This call will possibly drain all connections asynchronously.[m
[36m@@ -391,23 +393,23 @@[m [mvoid InternalEngine::onDefaultNetworkChanged(int network) {[m
   });[m
 }[m
 [m
[31m-void InternalEngine::onDefaultNetworkChangedAndroid(ConnectionType /*connection_type*/,[m
[31m-                                                    int64_t /*net_id*/) {[m
[31m-  ENVOY_LOG_MISC(trace, "Calling the default network changed callback on Android");[m
[32m+[m[32mvoid InternalEngine::onDefaultNetworkChangedAndroid(ConnectionType connection_type,[m
[32m+[m[32m                                                    int64_t net_id) {[m
[32m+[m[32m  connectivity_manager_->onDefaultNetworkChangedAndroid(connection_type, net_id);[m
 }[m
 [m
[31m-void InternalEngine::onNetworkDisconnectAndroid(int64_t /*net_id*/) {[m
[31m-  ENVOY_LOG_MISC(trace, "Calling network disconnect callback on Android");[m
[32m+[m[32mvoid InternalEngine::onNetworkDisconnectAndroid(int64_t net_id) {[m
[32m+[m[32m  connectivity_manager_->onNetworkDisconnectAndroid(net_id);[m
 }[m
 [m
[31m-void InternalEngine::onNetworkConnectAndroid(ConnectionType /*connection_type*/,[m
[31m-                                             int64_t /*net_id*/) {[m
[31m-  ENVOY_LOG_MISC(trace, "Calling network connect callback on Android");[m
[32m+[m[32mvoid InternalEngine::onNetworkConnectAndroid(ConnectionType connection_type,[m
[32m+[m[32m                                             int64_t net_id) {[m
[32m+[m[32m  connectivity_manager_->onNetworkConnectAndroid(connection_type, net_id);[m
 }[m
 [m
 void InternalEngine::purgeActiveNetworkListAndroid([m
[31m-    const std::vector<int64_t>& /*active_network_ids*/) {[m
[31m-  ENVOY_LOG_MISC(trace, "Calling network purge callback on Android");[m
[32m+[m[32m    const std::vector<int64_t>& active_network_ids) {[m
[32m+[m[32m  connectivity_manager_->purgeActiveNetworkListAndroid(active_network_ids);[m
 }[m
 [m
 void InternalEngine::onDefaultNetworkUnavailable() {[m
[1mdiff --git a/mobile/test/common/integration/client_integration_test.cc b/mobile/test/common/integration/client_integration_test.cc[m
[1mindex 26abde47da..55fdfba4b1 100644[m
[1m--- a/mobile/test/common/integration/client_integration_test.cc[m
[1m+++ b/mobile/test/common/integration/client_integration_test.cc[m
[36m@@ -103,6 +103,14 @@[m [mpublic:[m
       builder_.enableDnsCache(true, /* save_interval_seconds */ 1);[m
     }[m
 [m
[32m+[m[32m    // Initialize the connectivity manger with a WIFI default network and another network with unknown type.[m
[32m+[m[32m  std::vector<std::pair<int64_t, ConnectionType>> connected_networks{[m
[32m+[m[32m        {1, ConnectionType::CONNECTION_WIFI}, {2, ConnectionType::CONNECTION_UNKNOWN}};[m
[32m+[m[32m    EXPECT_CALL(helper_handle_->mock_helper(), getDefaultNetworkHandle()).WillOnce(Return(1));[m
[32m+[m[32m    EXPECT_CALL(helper_handle_->mock_helper(), getAllConnectedNetworks())[m
[32m+[m[32m        .WillOnce(Return(connected_networks));[m
[32m+[m
[32m+[m
     BaseClientIntegrationTest::initialize();[m
 [m
     if (getCodecType() == Http::CodecType::HTTP3) {[m
[36m@@ -362,6 +370,33 @@[m [mTEST_P(ClientIntegrationTest, HandleNetworkChangeEvents) {[m
   EXPECT_EQ(4, current_change_event);[m
 }[m
 [m
[32m+[m[32m/*[m
[32m+[m[32mTEST_P(ClientIntegrationTest, HandleNetworkChangeEventsAndroid) {[m
[32m+[m[32m    absl::Notification handled_network_change;[m
[32m+[m[32m  auto logger = std::make_unique<EnvoyLogger>();[m
[32m+[m[32m  logger->on_log_ = [&](Logger::Logger::Levels, const std::string& msg) {[m
[32m+[m[32m    if (msg.find("Default network state has been changed. Current net configuration key") != std::string::npos) {[m
[32m+[m[32m      handled_network_change.Notify();[m
[32m+[m[32m    }[m
[32m+[m[32m  };[m
[32m+[m[32m  builder_.setLogger(std::move(logger));[m
[32m+[m[32m  builder_.setDisableDnsRefreshOnNetworkChange(false);[m
[32m+[m
[32m+[m[32m  initialize();[m
[32m+[m[32m  EXPECT_EQ(0, getCounterValue("dns_cache.base_dns_cache.dns_query_attempt"));[m
[32m+[m
[32m+[m[32m  // A new WIFI network appeares and becomes the default network. Even though[m
[32m+[m[32m  // the test is intialized with a WIFI network, this should still have triggred[m
[32m+[m[32m  // a network change event as it has a different network handle.[m
[32m+[m[32m  internalEngine()->onNetworkConnectAndroid(ConnectionType::CONNECTION_WIFI, 123);[m
[32m+[m[32m  internalEngine()->onDefaultNetworkChangedAndroid(ConnectionType::CONNECTION_WIFI, 123);[m
[32m+[m[32m  // The HTTP status reset and DNS refresh should have been posted to the network thread and to be handled there.[m
[32m+[m[32m  handled_network_change.WaitForNotification();[m
[32m+[m[32m  // DNS has been force refreshed.[m
[32m+[m[32m  EXPECT_EQ(1, getCounterValue("dns_cache.base_dns_cache.dns_query_attempt"));[m
[32m+[m[32m}[m
[32m+[m[32m*/[m
[32m+[m
 TEST_P(ClientIntegrationTest, LargeResponse) {[m
   initialize();[m
   std::string data(1024 * 32, 'a');[m
[1mdiff --git a/source/extensions/common/dynamic_forward_proxy/dns_cache_impl.cc b/source/extensions/common/dynamic_forward_proxy/dns_cache_impl.cc[m
[1mindex 8037e43178..49fa581957 100644[m
[1m--- a/source/extensions/common/dynamic_forward_proxy/dns_cache_impl.cc[m
[1m+++ b/source/extensions/common/dynamic_forward_proxy/dns_cache_impl.cc[m
[36m@@ -9,6 +9,7 @@[m
 #include "source/common/network/dns_resolver/dns_factory_util.h"[m
 #include "source/common/network/utility.h"[m
 #include "source/common/runtime/runtime_features.h"[m
[32m+[m[32m#include "source/server/backtrace.h"[m
 [m
 namespace Envoy {[m
 namespace Extensions {[m
[36m@@ -121,6 +122,7 @@[m [mDnsCacheImpl::loadDnsCacheEntryWithForceRefresh(absl::string_view raw_host, uint[m
 [m
   ENVOY_LOG(debug, "thread local lookup for host '{}' {}", host,[m
             is_proxy_lookup ? "proxy mode " : "");[m
[32m+[m[32m  BACKTRACE_LOG();[m
   ThreadLocalHostInfo& tls_host_info = *tls_slot_;[m
 [m
   bool is_overflow = false;[m
[36m@@ -157,7 +159,7 @@[m [mDnsCacheImpl::loadDnsCacheEntryWithForceRefresh(absl::string_view raw_host, uint[m
     stats_.host_overflow_.inc();[m
     return {LoadDnsCacheEntryStatus::Overflow, nullptr, absl::nullopt};[m
   }[m
[31m-  ENVOY_LOG(debug, "cache miss for host '{}', posting to main thread", host);[m
[32m+[m[32m  ENVOY_LOG(debug, "cache miss for host '{}' port '{}', posting to main thread", host, default_port);[m
   main_thread_dispatcher_.post([m
       [this, host = std::string(host), default_port, is_proxy_lookup, ignore_cached_entries]() {[m
         startCacheLoad(host, default_port, is_proxy_lookup, ignore_cached_entries);[m
[36m@@ -210,6 +212,7 @@[m [mDnsCacheImpl::addUpdateCallbacks(UpdateCallbacks& callbacks) {[m
 [m
 void DnsCacheImpl::startCacheLoad(const std::string& host, uint16_t default_port,[m
                                   bool is_proxy_lookup, bool ignore_cached_entries) {[m
[32m+[m[32m  ENVOY_LOG_MISC(error, "====== startCacheLoad {}:{}", host, default_port);[m
   ASSERT(main_thread_dispatcher_.isThreadSafe());[m
 [m
   // It's possible for multiple requests to race trying to start a resolution. If a host is[m
[36m@@ -226,7 +229,7 @@[m [mvoid DnsCacheImpl::startCacheLoad(const std::string& host, uint16_t default_port[m
 [m
   if (primary_host) {[m
     if (!ignore_cached_entries || !primary_host->host_info_->firstResolveComplete()) {[m
[31m-      ENVOY_LOG(debug, "main thread resolve for host '{}' skipped. Entry present", host);[m
[32m+[m[32m      ENVOY_LOG_MISC(debug, "main thread resolve for host '{}' skipped. Entry present", host);[m
       return;[m
     }[m
     // The host was in cache but we want to force a refresh. Remove the host[m
[36m@@ -235,6 +238,7 @@[m [mvoid DnsCacheImpl::startCacheLoad(const std::string& host, uint16_t default_port[m
   }[m
 [m
   primary_host = createHost(host, default_port);[m
[32m+[m[32m  ENVOY_LOG_MISC(error, "======= createHost default port {}, primary host {} ", default_port, primary_host->port_);[m
   // If the DNS request was simply to create a host endpoint in a Dynamic Forward Proxy cluster,[m
   // fast fail the look-up as the address is not needed.[m
   if (is_proxy_lookup) {[m
[36m@@ -248,6 +252,7 @@[m [mvoid DnsCacheImpl::startCacheLoad(const std::string& host, uint16_t default_port[m
 DnsCacheImpl::PrimaryHostInfo* DnsCacheImpl::createHost(const std::string& host,[m
                                                         uint16_t default_port) {[m
   const auto host_attributes = Http::Utility::parseAuthority(host);[m
[32m+[m[32m  ENVOY_LOG_MISC(error, "====== parseAuthority() host: {}. host_attributes.host_ {}, port_ {}", host, host_attributes.host_, (host_attributes.port_.has_value() ? host_attributes.port_.value() : -1));[m
   // TODO(mattklein123): Right now, the same host with different ports will become two[m
   // independent primary hosts with independent DNS resolutions. I'm not sure how much this will[m
   // matter, but we could consider collapsing these down and sharing the underlying DNS resolution.[m
[1mdiff --git a/source/extensions/filters/http/dynamic_forward_proxy/proxy_filter.cc b/source/extensions/filters/http/dynamic_forward_proxy/proxy_filter.cc[m
[1mindex 8d4f82ad5a..1e626ff1ae 100644[m
[1m--- a/source/extensions/filters/http/dynamic_forward_proxy/proxy_filter.cc[m
[1m+++ b/source/extensions/filters/http/dynamic_forward_proxy/proxy_filter.cc[m
[36m@@ -325,10 +325,12 @@[m [mHttp::FilterHeadersStatus ProxyFilter::decodeHeaders(Http::RequestHeaderMap& hea[m
   }[m
   uint16_t port = host_attributes.port_.value_or(default_port);[m
 [m
[32m+[m[32m  ENVOY_LOG_MISC(error, "========= port {} from host_attributes", port);[m
   // Apply filter state overrides for host and port.[m
   uint32_t port_u32 = port;[m
   applyFilterStateOverrides(host, port_u32, decoder_callbacks_,[m
                             config_->allowDynamicHostFromFilterState());[m
[32m+[m[32m  ENVOY_LOG_MISC(error, "========= port override to {}", port_u32);[m
   port = port_u32;[m
 [m
   auto [status_, handle_, host_info_] = config_->cache().loadDnsCacheEntryWithForceRefresh([m
