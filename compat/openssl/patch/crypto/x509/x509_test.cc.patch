--- a/x509_test.cc
+++ b/x509_test.cc
@@ -1289,6 +1289,9 @@
           Verify(root_cross_signed.get(), {cross_signing_root.get()}, {},
                  /*crls=*/{}, /*flags=*/0, configure_callback));
 
+#ifdef BSSL_COMPAT // This next check fails for negative depths on OpenSSL
+      if (depth < 0) continue;
+#endif
       // An explicitly trusted self-signed certificate is unaffected by depth
       // checks.
       EXPECT_EQ(X509_V_OK,
@@ -2009,10 +2012,20 @@
       {GEN_URI, "foo:/not-a-url", "not-a-url",
        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
       {GEN_URI, "foo:///not-a-url", "not-a-url",
+#ifdef BSSL_COMPAT
+       // OpenSSL considers "foo:///not-a-url" to be a valid URI
+       X509_V_ERR_PERMITTED_VIOLATION},
+#else // BSSL_COMPAT
        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+#endif // BSSL_COMPAT
       {GEN_URI, "foo://:not-a-url", "not-a-url",
        X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+#ifdef BSSL_COMPAT
+      // OpenSSL considers "foo://" to be a valid URI
+      {GEN_URI, "foo://", "not-a-url", X509_V_ERR_PERMITTED_VIOLATION},
+#else // BSSL_COMPAT
       {GEN_URI, "foo://", "not-a-url", X509_V_ERR_UNSUPPORTED_NAME_SYNTAX},
+#endif // BSSL_COMPAT
       // Hosts are an exact match.
       {GEN_URI, "foo://example.com", "example.com", X509_V_OK},
       {GEN_URI, "foo://example.com:443", "example.com", X509_V_OK},
@@ -2071,14 +2084,23 @@
 
     bssl::UniquePtr<NAME_CONSTRAINTS> nc(NAME_CONSTRAINTS_new());
     ASSERT_TRUE(nc);
-    nc->permittedSubtrees = sk_GENERAL_SUBTREE_new_null();
+#ifdef BSSL_COMPAT // FIXME: See StackTest.test4
+    nc->permittedSubtrees = reinterpret_cast<ossl_STACK_OF(ossl_GENERAL_SUBTREE)*>(sk_GENERAL_SUBTREE_new_null());
+#else
+     nc->permittedSubtrees = sk_GENERAL_SUBTREE_new_null();
+#endif
     ASSERT_TRUE(nc->permittedSubtrees);
     bssl::UniquePtr<GENERAL_SUBTREE> subtree(GENERAL_SUBTREE_new());
     ASSERT_TRUE(subtree);
     GENERAL_NAME_free(subtree->base);
     subtree->base = MakeGeneralName(t.type, t.constraint).release();
     ASSERT_TRUE(subtree->base);
-    ASSERT_TRUE(bssl::PushToStack(nc->permittedSubtrees, std::move(subtree)));
+#ifdef BSSL_COMPAT // FIXME:
+    ASSERT_TRUE(bssl::PushToStack(reinterpret_cast<STACK_OF(GENERAL_SUBTREE)*>(nc->permittedSubtrees), std::move(subtree)));
+#else
+     ASSERT_TRUE(bssl::PushToStack(nc->permittedSubtrees, std::move(subtree)));
+#endif
+
 
     bssl::UniquePtr<X509> root =
         MakeTestCert("Root", "Root", key.get(), /*is_ca=*/true);
@@ -3097,11 +3119,13 @@
   // |X509_check_purpose| with |X509_PURPOSE_ANY| and purpose -1 do not check
   // basicConstraints, but other purpose types do. (This is redundant with the
   // actual basicConstraints check, but |X509_check_purpose| is public API.)
+#ifndef BSSL_COMPAT
   EXPECT_TRUE(X509_check_purpose(intermediate.get(), -1, /*ca=*/1));
   EXPECT_TRUE(
       X509_check_purpose(intermediate.get(), X509_PURPOSE_ANY, /*ca=*/1));
   EXPECT_FALSE(X509_check_purpose(intermediate.get(), X509_PURPOSE_SSL_SERVER,
                                   /*ca=*/1));
+#endif // BSSL_COMPAT
 }
 
 TEST(X509Test, NoBasicConstraintsNetscapeCA) {
@@ -3994,6 +4018,7 @@
 t6uPxHrmpUY=
 -----END CERTIFICATE-----
 )";
+#ifndef BSSL_COMPAT
 static const char kP256InvalidParam[] = R"(
 -----BEGIN CERTIFICATE-----
 MIIBMTCBz6ADAgECAgIE0jATBggqhkjOPQQDAgQHZ2FyYmFnZTAPMQ0wCwYDVQQD
@@ -4005,6 +4030,7 @@
 fLULTZnynuQUULQkRcF7S7T2WpIL
 -----END CERTIFICATE-----
 )";
+#endif
 static const char kRSANoParam[] = R"(
 -----BEGIN CERTIFICATE-----
 MIIBWzCBx6ADAgECAgIE0jALBgkqhkiG9w0BAQswDzENMAsGA1UEAxMEVGVzdDAg
@@ -4029,6 +4055,7 @@
 SwmQUz4bRpckRBj+sIyp1We+pg==
 -----END CERTIFICATE-----
 )";
+#ifndef BSSL_COMPAT
 static const char kRSAInvalidParam[] = R"(
 -----BEGIN CERTIFICATE-----
 MIIBbTCB0KADAgECAgIE0jAUBgkqhkiG9w0BAQsEB2dhcmJhZ2UwDzENMAsGA1UE
@@ -4041,7 +4068,7 @@
 5OMNZ/ajVwOssw61GcAlScRqEHkZFBoGp7e+QpgB2tf9
 -----END CERTIFICATE-----
 )";
-
+#endif
 TEST(X509Test, AlgorithmParameters) {
   // P-256 parameters should be omitted, but we accept NULL ones.
   bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
@@ -4055,11 +4082,13 @@
   ASSERT_TRUE(cert);
   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
 
+#ifndef BSSL_COMPAT
   cert = CertFromPEM(kP256InvalidParam);
   ASSERT_TRUE(cert);
   EXPECT_FALSE(X509_verify(cert.get(), key.get()));
   EXPECT_TRUE(
       ErrorEquals(ERR_get_error(), ERR_LIB_X509, X509_R_INVALID_PARAMETER));
+#endif
 
   // RSA parameters should be NULL, but we accept omitted ones.
   key = PrivateKeyFromPEM(kRSAKey);
@@ -4073,11 +4102,13 @@
   ASSERT_TRUE(cert);
   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
 
+#ifndef BSSL_COMPAT
   cert = CertFromPEM(kRSAInvalidParam);
   ASSERT_TRUE(cert);
   EXPECT_FALSE(X509_verify(cert.get(), key.get()));
   EXPECT_TRUE(
       ErrorEquals(ERR_get_error(), ERR_LIB_X509, X509_R_INVALID_PARAMETER));
+#endif
 }
 
 TEST(X509Test, GeneralName) {
