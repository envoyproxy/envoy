--- a/
+++ b/
@@ -87,13 +87,19 @@
 static const size_t kTicketKeyLen = 48;
 
 static const VersionParam kAllVersions[] = {
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports TLS 1.0 or TLS1.1
     {TLS1_VERSION, VersionParam::is_tls, "TLS1"},
     {TLS1_1_VERSION, VersionParam::is_tls, "TLS1_1"},
+#endif    
     {TLS1_2_VERSION, VersionParam::is_tls, "TLS1_2"},
     {TLS1_3_VERSION, VersionParam::is_tls, "TLS1_3"},
+#ifndef BSSL_COMPAT // OpenSSL 3.0.x no longer supports DTLS 1.0
     {DTLS1_VERSION, VersionParam::is_dtls, "DTLS1"},
+#endif
     {DTLS1_2_VERSION, VersionParam::is_dtls, "DTLS1_2"},
+#ifdef DTLS1_3_EXPERIMENTAL_VERSION    
     {DTLS1_3_VERSION, VersionParam::is_dtls, "DTLS1_3"},
+#endif // DTLS1_3_EXPERIMENTAL_VERSION
 };
 
 struct ExpectedCipher {
@@ -1324,6 +1330,7 @@
     int auth_nid;
     int prf_nid;
   } kTests[] = {
+#ifdef SSL_CIPHER_RSA_WITH_3DES_EDE_CBC_SHA
       {
           SSL_CIPHER_RSA_WITH_3DES_EDE_CBC_SHA,
           "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
@@ -1333,6 +1340,7 @@
           NID_auth_rsa,
           NID_md5_sha1,
       },
+#endif // SSL_CIPHER_RSA_WITH_3DES_EDE_CBC_SHA
       {
           SSL_CIPHER_RSA_WITH_AES_128_CBC_SHA,
           "TLS_RSA_WITH_AES_128_CBC_SHA",
@@ -1880,7 +1888,11 @@
     if (client_err != SSL_ERROR_NONE &&        //
         client_err != SSL_ERROR_WANT_READ &&   //
         client_err != SSL_ERROR_WANT_WRITE &&  //
+#ifdef SSL_ERROR_PENDING_TICKET   
         client_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif      
       fprintf(stderr, "Client error: %s\n", SSL_error_description(client_err));
       return false;
     }
@@ -1890,7 +1902,11 @@
     if (server_err != SSL_ERROR_NONE &&        //
         server_err != SSL_ERROR_WANT_READ &&   //
         server_err != SSL_ERROR_WANT_WRITE &&  //
+#ifdef SSL_ERROR_PENDING_TICKET         
         server_err != SSL_ERROR_PENDING_TICKET) {
+#else
+        true) {
+#endif
       fprintf(stderr, "Server error: %s\n", SSL_error_description(server_err));
       return false;
     }
@@ -1979,7 +1995,12 @@
     return false;
   }
   if (config.early_data) {
+#ifndef BSSL_COMPAT
     SSL_set_early_data_enabled(client.get(), 1);
+#else
+    std::cout << "WARNING: Skipped SSL_set_early_data_enabled()" << std::endl;
+    return false;
+#endif
   }
   if (config.session) {
     SSL_set_session(client.get(), config.session);
@@ -1989,18 +2010,29 @@
     return false;
   }
   if (!config.verify_hostname.empty()) {
+#ifndef BSSL_COMPAT
     if (!SSL_set1_host(client.get(), config.verify_hostname.c_str())) {
       return false;
     }
     SSL_set_hostflags(client.get(), config.hostflags);
+#else
+    std::cout << "WARNING: Skipped SSL_set1_host() & SSL_set_hostflags()" << std::endl;
+    return false;
+#endif
   }
 
   if (config.ca_names) {
     SSL_set0_CA_names(client.get(), config.ca_names);
   }
 
+#ifndef BSSL_COMPAT
   SSL_set_shed_handshake_config(client.get(), shed_handshake_config);
   SSL_set_shed_handshake_config(server.get(), shed_handshake_config);
+#else
+  if(shed_handshake_config) {
+    std::cout << "WARNING: Skipped SSL_set_shed_handshake_config()" << std::endl;
+  }
+#endif
 
   if (!CompleteHandshakes(client.get(), server.get())) {
     return false;
@@ -3858,12 +3890,16 @@
   // However, for historical reasons, the X509 chain includes the leaf on the
   // client, but does not on the server.
   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(client_.get())), 1u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(client_.get())),
             1u);
+#endif
 
   EXPECT_EQ(sk_X509_num(SSL_get_peer_cert_chain(server_.get())), 0u);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this  
   EXPECT_EQ(sk_CRYPTO_BUFFER_num(SSL_get0_peer_certificates(server_.get())),
             1u);
+#endif
 }
 
 TEST_P(SSLVersionTest, NoPeerCertificate) {
@@ -3876,7 +3912,9 @@
   // Server should not see a peer certificate.
   bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));
   ASSERT_FALSE(peer);
+#ifndef BSSL_COMPAT // Envoy doesn't need SSL_get0_peer_certificates() so skip this
   ASSERT_FALSE(SSL_get0_peer_certificates(server_.get()));
+#endif
 }
 
 TEST_P(SSLVersionTest, RetainOnlySHA256OfCerts) {
@@ -4569,7 +4607,11 @@
   ASSERT_TRUE(CreateClientAndServer(&client_, &server_, client_ctx_.get(),
                                     server_ctx_.get()));
   // Before the handshake, |SSL_version| reports some placeholder value.
+#ifdef BSSL_COMPAT // Default versions are different when running on OpenSSL
+  const uint16_t placeholder = is_dtls() ? DTLS1_2_VERSION : TLS1_3_VERSION;
+#else
   const uint16_t placeholder = is_dtls() ? DTLS1_2_VERSION : TLS1_2_VERSION;
+#endif
   EXPECT_EQ(SSL_version(client_.get()), placeholder);
   EXPECT_EQ(SSL_version(server_.get()), placeholder);
 
@@ -6217,8 +6259,13 @@
   int ret = SSL_do_handshake(ssl.get());
   EXPECT_EQ(-1, ret);
   EXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(ssl.get(), ret));
+#ifdef BSSL_COMPAT
+  EXPECT_TRUE(
+      ErrorEquals(ERR_get_error(), ERR_LIB_SSL, ossl_SSL_R_NO_PROTOCOLS_AVAILABLE));
+#else // BSSL_COMPAT
   EXPECT_TRUE(
       ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_NO_CIPHERS_AVAILABLE));
+#endif // BSSL_COMPAT
 }
 
 TEST_P(SSLVersionTest, SessionVersion) {
