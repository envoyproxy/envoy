#!/usr/bin/env bash
#
# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

DUMMY_SHA=0000000000000000000000000000000000000000

echo "Running pre-push check; to skip this step use 'push --no-verify'"

while read LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA
do
  if [ "$LOCAL_SHA" = $DUMMY_SHA ]
  then
    # Branch deleted. Do nothing.
    exit 0
  else
    if [ "$REMOTE_SHA" = $DUMMY_SHA ]
    then
      # New branch. Verify last 15 commits, since verification of the entire
      # history would take too much time.
      RANGE="$LOCAL_SHA~15..$LOCAL_SHA"
    else
      # Updating branch. Verify new commits.
      RANGE="$REMOTE_SHA..$LOCAL_SHA"
    fi

    # Verify DCO signoff. We do this before the format checker, since it has
    # some probability of failing spuriously, while this check never should.
    #
    # In general, we can't assume that the commits are signed off by author
    # pushing, so we settle for just checking that there is a signoff at all.
    SIGNED_OFF=$(git rev-list --grep "^Signed-off-by: " "$RANGE")
    NOT_SIGNED_OFF=$(git rev-list "$RANGE" | grep -Fxv "$SIGNED_OFF")
    if [ -n "$NOT_SIGNED_OFF" ]
    then
      echo >&2 "ERROR: The following commits do not have DCO signoff:"
      while read -r commit; do
        echo "  $(git log --pretty=oneline --abbrev-commit -n 1 $commit)"
      done <<< "$NOT_SIGNED_OFF"
      exit 1
    fi

    # NOTE: The `tools` directory will be the same relative to the support
    # directory, independent of whether we're in a submodule, so no need to use
    # our `relpath` helper.
    SCRIPT_DIR="$(dirname "$(realpath "$0")")/../../tools"

    # TODO(hausdorff): We should have a more graceful failure story when the
    # user does not have all the tools set up correctly. This script assumes
    # `$CLANG_FORMAT` and `$BUILDIFY` are defined, or that the default values it
    # assumes for these variables correspond to real binaries on the system. If
    # either of these things aren't true, the check fails.
    for i in $(git diff --name-only $RANGE --diff-filter=ACMR 2>&1); do
      echo "  Checking format for $i"
      "$SCRIPT_DIR"/check_format.py check $i
      if [[ $? -ne 0 ]]; then
        exit 1
      fi
    done
  fi
done

exit 0
