#pragma once

#include <memory>
#include <string>
#include <vector>

#include "envoy/common/platform.h"
#include "envoy/network/connection.h"
#include "envoy/network/listen_socket.h"
#include "envoy/network/socket.h"
#include "envoy/network/socket_interface.h"

#include "source/common/common/assert.h"
#include "source/common/common/dump_state_utils.h"
#include "source/common/network/socket_impl.h"
#include "source/common/network/socket_interface.h"

#include "absl/status/statusor.h"

namespace Envoy {
namespace Network {

/**
 * Wraps a unix socket.
 */
template <Socket::Type T> struct NetworkSocketTrait {};

template <> struct NetworkSocketTrait<Socket::Type::Stream> {
  static constexpr Socket::Type type = Socket::Type::Stream;
};

template <> struct NetworkSocketTrait<Socket::Type::Datagram> {
  static constexpr Socket::Type type = Socket::Type::Datagram;
};

class ConnectionSocketImpl : public SocketImpl, public ConnectionSocket {
public:
  ConnectionSocketImpl(IoHandlePtr&& io_handle,
                       const Address::InstanceConstSharedPtr& local_address,
                       const Address::InstanceConstSharedPtr& remote_address)
      : SocketImpl(std::move(io_handle), local_address, remote_address) {}

  static absl::StatusOr<std::unique_ptr<ConnectionSocketImpl>>
  create(Socket::Type type, const Address::InstanceConstSharedPtr& local_address,
         const Address::InstanceConstSharedPtr& remote_address,
         const SocketCreationOptions& options) {
    absl::StatusOr<IoHandlePtr> io_handle_or = ioHandleForAddr(type, local_address, options);
    RETURN_IF_NOT_OK(io_handle_or.status());

    return std::unique_ptr<ConnectionSocketImpl>(new ConnectionSocketImpl(
        std::move(*io_handle_or), type, local_address->type(), local_address, remote_address));
  }

  // Network::ConnectionSocket
  void setDetectedTransportProtocol(absl::string_view protocol) override {
    transport_protocol_ = std::string(protocol);
  }
  absl::string_view detectedTransportProtocol() const override { return transport_protocol_; }

  void setRequestedApplicationProtocols(const std::vector<absl::string_view>& protocols) override {
    connectionInfoProvider().setRequestedApplicationProtocols(protocols);
  }
  const std::vector<std::string>& requestedApplicationProtocols() const override {
    return connectionInfoProvider().requestedApplicationProtocols();
  }

  void setRequestedServerName(absl::string_view server_name) override {
    // Always keep the server_name_ as lower case.
    connectionInfoProvider().setRequestedServerName(absl::AsciiStrToLower(server_name));
  }
  absl::string_view requestedServerName() const override {
    return connectionInfoProvider().requestedServerName();
  }

  void setJA3Hash(absl::string_view ja3_hash) override {
    connectionInfoProvider().setJA3Hash(ja3_hash);
  }
  absl::string_view ja3Hash() const override { return connectionInfoProvider().ja3Hash(); }

  void setJA4Hash(absl::string_view ja4_hash) override {
    connectionInfoProvider().setJA4Hash(ja4_hash);
  }
  absl::string_view ja4Hash() const override { return connectionInfoProvider().ja4Hash(); }

  absl::optional<std::chrono::milliseconds> lastRoundTripTime() override {
    return ioHandle().lastRoundTripTime();
  }

  absl::optional<uint64_t> congestionWindowInBytes() const override {
    return ioHandle().congestionWindowInBytes();
  }

  void dumpState(std::ostream& os, int indent_level) const override {
    const char* spaces = spacesForLevel(indent_level);
    os << spaces << "ListenSocketImpl " << this << DUMP_MEMBER(transport_protocol_) << "\n";
    DUMP_DETAILS(connection_info_provider_);
  }

protected:
  ConnectionSocketImpl(IoHandlePtr&& io_handle, Socket::Type sock_type, Address::Type addr_type,
                       const Address::InstanceConstSharedPtr& local_address,
                       const Address::InstanceConstSharedPtr& remote_address)
      : SocketImpl(std::move(io_handle), sock_type, addr_type, remote_address) {
    connection_info_provider_->setLocalAddress(local_address);
  }

  std::string transport_protocol_;
};

// ConnectionSocket used with client connections.
class ClientSocketImpl : public ConnectionSocketImpl {
public:
  static absl::StatusOr<std::unique_ptr<ClientSocketImpl>>
  create(const Address::InstanceConstSharedPtr& remote_address, const OptionsSharedPtr& options) {
    absl::StatusOr<IoHandlePtr> io_handle_or =
        ioHandleForAddr(Socket::Type::Stream, remote_address, {});
    RETURN_IF_NOT_OK(io_handle_or.status());

    return std::unique_ptr<ClientSocketImpl>(
        new ClientSocketImpl(std::move(*io_handle_or), remote_address, options));
  }

protected:
  ClientSocketImpl(IoHandlePtr&& io_handle, const Address::InstanceConstSharedPtr& remote_address,
                   const OptionsSharedPtr& options)
      : ConnectionSocketImpl(std::move(io_handle), nullptr, remote_address) {
    if (options) {
      addOptions(options);
    }
  }
};

} // namespace Network
} // namespace Envoy
