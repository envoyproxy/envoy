syntax = "proto3";

package envoy.service.rate_limit_quota.v3;

import "envoy/type/v3/ratelimit_strategy.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.service.rate_limit_quota.v3";
option java_outer_classname = "RlqsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/service/rate_limit_quota/v3;rate_limit_quotav3";
option java_generic_services = true;
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#not-implemented-hide:]
// [#protodoc-title: Rate Limit Quota Service (RLQS)]

service RateLimitQuotaService {
  rpc StreamRateLimitQuotas(stream RateLimitQuotaUsageReports)
      returns (stream RateLimitQuotaResponse) {
  }
}

message RateLimitQuotaUsageReports {
  // [#next-free-field: 6]
  message BucketQuotaUsage {
    // Bucket id for which request quota usage is reported.
    BucketId bucket_id = 1 [(validate.rules).message = {required: true}];

    // Time elapsed since the last report.
    google.protobuf.Duration time_elapsed = 2;

    // Requests the data plane has allowed through.
    uint64 num_requests_allowed = 3;

    // Requests throttled.
    uint64 num_requests_denied = 4;

    // Requests in the queue waiting for the assignment.
    uint64 num_requests_queued = 5;
  }

  // All quota requests must specify the domain. This enables sharing the quota
  // server between different applications without fear of overlap.
  // E.g., "envoy".
  // [#comment:TODO(sergiitk): add a note about domain being optional after the first report]
  // [#comment:TODO(sergiitk): add a note about closing a stream on domain change.]
  string domain = 1;

  // A list of quota usage reports for each bucket.
  repeated BucketQuotaUsage bucket_quota_usages = 2 [(validate.rules).repeated = {min_items: 1}];
}

message RateLimitQuotaResponse {
  message BucketAction {
    message QuotaAssignmentAction {
      // A duration after which the assignment should be considered expired if it
      // hasn't received a new value.
      // If unset, the assignment has no expiration date.
      google.protobuf.Duration assignment_time_to_live = 2;

      // Rate limiter strategy determines the implementation details for when to
      // allow and deny the requests matched to the bucket.
      // If unset, no limit.
      type.v3.RateLimitStrategy rate_limit_strategy = 3;
    }

    message AbandonAction {
    }

    // Bucket id for which to take the action.
    BucketId bucket_id = 1 [(validate.rules).message = {required: true}];

    oneof bucket_action {
      // Apply quota assignment to the bucket.
      // When the quota is different from bucket's active assignment,
      // the data plane must immediately end the assignment, and
      // report the usage.
      QuotaAssignmentAction quota_assignment_action = 2;

      // Abandon the bucket.
      // If no requests are reported for a bucket, after some time the server
      // considers the bucket inactive. The server stops tracking the bucket,
      // and instructs the client to abandon the bucket via this message.
      // The client is to purge the bucket from the memory, and to stop tracking
      // the bucket until there's a new request matched into the bucket.
      // Functionally this identical to the state before client has matched the
      // first request to the bucket, and sent bucket's first usage report.
      AbandonAction abandon_action = 3;
    }
  }

  // An ordered list of actions to be applied to the buckets.
  repeated BucketAction bucket_action = 1;
}

// The identifier for the bucket. Used to match the bucket on the control
// plane (RLQS server), and on the data plane (RLQS client).
message BucketId {
  map<string, string> bucket = 1;
}
