syntax = "proto3";

package envoy.service.rate_limit_quota.v3;

import "envoy/type/v3/ratelimit_strategy.proto";

import "google/protobuf/duration.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.service.rate_limit_quota.v3";
option java_outer_classname = "RlqsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/service/rate_limit_quota/v3;rate_limit_quotav3";
option java_generic_services = true;
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: Rate Limit Quota Service (RLQS)]

// The Rate Limit Quota Service (RLQS) is a Envoy global rate limiting service that allows to
// delegate rate limit decisions to a remote service. The service will aggregate the usage reports
// from multiple data plane instances, and distribute Rate Limit Assignments to each instance
// based on its business logic. The logic is outside of the scope of the protocol API.
//
// The protocol is designed as a streaming-first. It utilizes watch-like subscription model.
// The data plane groups requests into Quota Buckets as directed by the filter config,
// and periodically reports them to the RLQS server along with the Bucket identifier, :ref:`BucketId
// <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`. Once RLQS server has collected enough
// reports to make a decision, it'll send back the assignment with the rate limiting instructions.
//
// The first report sent by the data plane is interpreted by the RLQS server as a "watch" request,
// indicating that the data plane instance is interested in receiving further updates for the
// ``BucketId``. From then on, RLQS server may push assignments to this instance at will, even if
// the instance is not sending usage reports. It's the responsibility of the RLQS server
// to determine when the data plane instance didn't send ``BucketId`` reports for too long,
// and to respond with the :ref:`AbandonAction
// <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`,
// indicating that the server has now stopped sending quota assignments for the ``BucketId`` bucket,
// and the data plane instance should :ref:`abandon
// <envoy_v3_api_field_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.abandon_action>`
// it.
//
// Refer to Rate Limit Quota :ref:`configuration overview <config_http_filters_rate_limit_quota>`
// for further details.

// Defines the Rate Limit Quota Service (RLQS).
service RateLimitQuotaService {
  // Main communication channel: the data plane sends usage reports to the RLQS server,
  // and the server asynchronously responding with the assignments.
  rpc StreamRateLimitQuotas(stream RateLimitQuotaUsageReports)
      returns (stream RateLimitQuotaResponse) {
  }
}

message RateLimitQuotaUsageReports {
  // The usage report for a bucket.
  //
  // .. note::
  //   Note that the first report sent for a ``BucketId`` indicates to the RLQS server that
  //   the RLQS client is subscribing for the future assignments for this ``BucketId``.
  //
  // [#next-free-field: 6]
  message BucketQuotaUsage {
    // ``BucketId`` for which request quota usage is reported.
    BucketId bucket_id = 1 [(validate.rules).message = {required: true}];

    // Time elapsed since the last report.
    google.protobuf.Duration time_elapsed = 2 [(validate.rules).duration = {
      required: true
      gt {}
    }];

    // Requests the data plane has allowed through.
    uint64 num_requests_allowed = 3;

    // Requests throttled.
    uint64 num_requests_denied = 4;

    // Requests in the queue waiting for the assignment.
    uint64 num_requests_queued = 5;
  }

  // All quota requests must specify the domain. This enables sharing the quota
  // server between different applications without fear of overlap.
  // E.g., "envoy".
  //
  // Should only be provided in the first report, all subsequent messages on the same
  // stream are considered to be in the same domain. In case the domain needs to be
  // changes, close the stream, and reopen a new one with the different domain.
  string domain = 1 [(validate.rules).string = {min_len: 1}];

  // A list of quota usage reports. In most cases the order doesn't matter, except the case when
  // the list contains multiple reports of the same ``BucketId``. Then the earlier report must come
  // first.
  repeated BucketQuotaUsage bucket_quota_usages = 2 [(validate.rules).repeated = {min_items: 1}];
}

message RateLimitQuotaResponse {
  message BucketAction {
    // Quota Assignment for the ``BucketId``. Configures the rate limiting strategy and duration.
    message QuotaAssignmentAction {
      // A duration after which the assignment is be considered expired.
      //
      // If unset, the assignment has no expiration date.
      //
      // .. attention::
      //   Zero-second ``Duration`` expires **immediately**, while unset ``Duration``
      //   **has no expiration date**.
      google.protobuf.Duration assignment_time_to_live = 2 [(validate.rules).duration = {gte {}}];

      // Configures the local rate limiter for the request matched to the bucket.
      //
      // If not set, no allow all requests.
      type.v3.RateLimitStrategy rate_limit_strategy = 3;
    }

    // Abandon action for the bucket. Indicates that the RLQS server will no longer be
    // sending updates for this ``BucketId``.
    message AbandonAction {
    }

    // ``BucketId`` for which request the action is applied.
    BucketId bucket_id = 1 [(validate.rules).message = {required: true}];

    oneof bucket_action {
      option (validate.required) = true;

      // Apply the quota assignment to the bucket.
      //
      // When the quota is different from bucket's active assignment, the data plane must
      // immediately end the previous assignment, report the usage, and apply the new assignment.
      QuotaAssignmentAction quota_assignment_action = 2;

      // Abandon the bucket.
      //
      // If no requests are reported for a bucket, after some time the server considers the bucket
      // inactive. The server stops tracking the bucket, and instructs the client to abandon the
      // bucket via this message.
      //
      // The client is to purge the bucket from the memory, and to stop tracking the bucket until
      // there's a new request matched into the bucket. Functionally this identical to the
      // state before client has matched the first request to the bucket, and
      // sent bucket's first usage report ("no assignment behavior").
      AbandonAction abandon_action = 3;
    }
  }

  // An ordered list of actions to be applied to the buckets. The actions are applied in the
  // given order, from top to bottom.
  repeated BucketAction bucket_action = 1 [(validate.rules).repeated = {min_items: 1}];
}

// The identifier for the bucket. Used to match the bucket between the control plane (RLQS server),
// and the data plane (RLQS client), f.e.:
//
// * the data plane sends a usage report for requests matched into the bucket with ``BucketId``
//   to the control plane
// * the control plane sends an assignment for the bucket with ``BucketId`` to the data plane
//   Bucket ID.
//
// Example:
//
// .. validated-code-block:: yaml
//   :type-name: envoy.service.rate_limit_quota.v3.BucketId
//
//   bucket:
//     name: my_bucket
//     env: staging
//
// .. note::
//   The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
//   ``{ b: 'B', a: 'A' }`` are identical.
message BucketId {
  map<string, string> bucket = 1 [(validate.rules).map = {
    min_pairs: 1
    keys {string {min_len: 1}}
    values {string {min_len: 1}}
  }];
}
