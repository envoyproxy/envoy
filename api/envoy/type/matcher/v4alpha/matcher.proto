syntax = "proto3";

package envoy.type.matcher.v4alpha;

import "envoy/type/matcher/v4alpha/header.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.config.common.matcher.v4alpha";
option java_outer_classname = "MatcherProto";
option java_multiple_files = true;
option (udpa.annotations.file_status).package_version_status = NEXT_MAJOR_VERSION_CANDIDATE;

// TODO(shivanshu21): Once HeaderMatcher is deprecated in favor of StringMatcher,
// this file will no longer be required as the dependency from
// envoy.config.common.matcher to route.v3.HeaderMatcher will be broken.

// [#protodoc-title: Logical Matcher API]

// Match configuration. This is a recursive structure which allows complex nested match
// configurations to be built using various logical operators.
// [#next-free-field: 6]
message MatchPredicate {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.type.matcher.v3.MatchPredicate";

  // A set of match configurations used for logical operations.
  message MatchSet {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.type.matcher.v3.MatchPredicate.MatchSet";

    // The list of rules that make up the set.
    repeated MatchPredicate rules = 1 [(validate.rules).repeated = {min_items: 2}];
  }

  oneof rule {
    option (validate.required) = true;

    // A set that describes a logical OR. If any member of the set matches, the match configuration
    // matches.
    MatchSet or_match = 1;

    // A set that describes a logical AND. If all members of the set match, the match configuration
    // matches.
    MatchSet and_match = 2;

    // A negation match. The match configuration will match if the negated match condition matches.
    MatchPredicate not_match = 3;

    // The match configuration will always match.
    bool any_match = 4 [(validate.rules).bool = {const: true}];

    // HTTP response headers match configuration.
    HttpHeadersMatch http_headers_match = 5;

  }
}

// HTTP headers match configuration.
message HttpHeadersMatch {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.type.matcher.v3.HttpHeadersMatch";

  // HTTP headers to match.
  repeated type.matcher.v4alpha.HeaderMatcher headers = 1;
}
