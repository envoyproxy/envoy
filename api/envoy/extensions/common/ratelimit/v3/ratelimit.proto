syntax = "proto3";

package envoy.extensions.common.ratelimit.v3;

import "envoy/config/core/v3/extension.proto";
import "envoy/config/route/v3/route_components.proto";
import "envoy/type/metadata/v3/metadata.proto";
import "envoy/type/v3/ratelimit_unit.proto";
import "envoy/type/v3/token_bucket.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.common.ratelimit.v3";
option java_outer_classname = "RatelimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/common/ratelimit/v3;ratelimitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Common rate limit components]

// Defines the version of the standard to use for X-RateLimit headers.
enum XRateLimitHeadersRFCVersion {
  // X-RateLimit headers disabled.
  OFF = 0;

  // Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_ where 3 headers will be added:
  //
  // * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
  //   client in the current time-window followed by the description of the
  //   quota policy. The value is returned by the maximum tokens of the token bucket.
  // * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
  //   current time-window. The value is returned by the remaining tokens in the token bucket.
  // * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
  //   the current time-window. The value is returned by the remaining fill interval of the token bucket.
  DRAFT_VERSION_03 = 1;
}

enum VhRateLimitsOptions {
  // Use the virtual host rate limits unless the route has a rate limit policy.
  OVERRIDE = 0;

  // Use the virtual host rate limits even if the route has a rate limit policy.
  INCLUDE = 1;

  // Ignore the virtual host rate limits even if the route does not have a rate limit policy.
  IGNORE = 2;
}

// A RateLimitDescriptor is a list of hierarchical entries that are used by the service to
// determine the final rate limit key and overall allowed limit. Here are some examples of how
// they might be used for the domain "envoy".
//
// .. code-block:: cpp
//
//   ["authenticated": "false"], ["remote_address": "10.0.0.1"]
//
// What it does: Limits all unauthenticated traffic for the IP address 10.0.0.1. The
// configuration supplies a default limit for the *remote_address* key. If there is a desire to
// raise the limit for 10.0.0.1 or block it entirely it can be specified directly in the
// configuration.
//
// .. code-block:: cpp
//
//   ["authenticated": "false"], ["path": "/foo/bar"]
//
// What it does: Limits all unauthenticated traffic globally for a specific path (or prefix if
// configured that way in the service).
//
// .. code-block:: cpp
//
//   ["authenticated": "false"], ["path": "/foo/bar"], ["remote_address": "10.0.0.1"]
//
// What it does: Limits unauthenticated traffic to a specific path for a specific IP address.
// Like (1) we can raise/block specific IP addresses if we want with an override configuration.
//
// .. code-block:: cpp
//
//   ["authenticated": "true"], ["client_id": "foo"]
//
// What it does: Limits all traffic for an authenticated client "foo"
//
// .. code-block:: cpp
//
//   ["authenticated": "true"], ["client_id": "foo"], ["path": "/foo/bar"]
//
// What it does: Limits traffic to a specific path for an authenticated client "foo"
//
// The idea behind the API is that (1)/(2)/(3) and (4)/(5) can be sent in 1 request if desired.
// This enables building complex application scenarios with a generic backend.
//
// Optionally the descriptor can contain a limit override under a "limit" key, that specifies
// the number of requests per unit to use instead of the number configured in the
// rate limiting service.
message RateLimitDescriptor {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.api.v2.ratelimit.RateLimitDescriptor";

  message Entry {
    option (udpa.annotations.versioning).previous_message_type =
        "envoy.api.v2.ratelimit.RateLimitDescriptor.Entry";

    // Descriptor key.
    string key = 1 [(validate.rules).string = {min_len: 1}];

    // Descriptor value.
    string value = 2 [(validate.rules).string = {min_len: 1}];
  }

  // Override rate limit to apply to this descriptor instead of the limit
  // configured in the rate limit service. See :ref:`rate limit override
  // <config_http_filters_rate_limit_rate_limit_override>` for more information.
  message RateLimitOverride {
    // The number of requests per unit of time.
    uint32 requests_per_unit = 1;

    // The unit of time.
    type.v3.RateLimitUnit unit = 2 [(validate.rules).enum = {defined_only: true}];
  }

  // Descriptor entries.
  repeated Entry entries = 1 [(validate.rules).repeated = {min_items: 1}];

  // Optional rate limit override to supply to the ratelimit service.
  RateLimitOverride limit = 2;
}

message LocalRateLimitDescriptor {
  // Descriptor entries.
  repeated v3.RateLimitDescriptor.Entry entries = 1 [(validate.rules).repeated = {min_items: 1}];

  // Token Bucket algorithm for local ratelimiting.
  type.v3.TokenBucket token_bucket = 2 [(validate.rules).message = {required: true}];
}

// Configuration used to enable local cluster level rate limiting where the token buckets
// will be shared across all the Envoy instances in the local cluster.
// A share will be calculated based on the membership of the local cluster dynamically
// and the configuration. When the limiter refilling the token bucket, the share will be
// applied. By default, the token bucket will be shared evenly.
//
// See :ref:`local cluster name
// <envoy_v3_api_field_config.bootstrap.v3.ClusterManager.local_cluster_name>` for more context
// about local cluster.
message LocalClusterRateLimit {
}

// Rate limit config that used to generate a list of descriptor entries (a list of key/value pairs)
// based on the request context. The generated entries will be used to much a specific rate limit
// rule.
// Take the local rate limit extension as an example, the generated entries will be used to find a
// ``LocalRateLimitDescriptor`` which contains a token bucket. And the token bucket will be used to
// limit the request rate.
// [#not-implemented-hide:]
message RateLimitConfig {
  // [#next-free-field: 11]
  message Action {
    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("source_cluster", "<local service cluster>")
    //
    // <local service cluster> is derived from the :option:`--service-cluster` option.
    message SourceCluster {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("destination_cluster", "<routed target cluster>")
    //
    // Once a request matches against a route table rule, a routed cluster is determined by one of
    // the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
    // settings:
    //
    // * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
    //   to route to.
    // * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
    //   chooses a cluster randomly from a set of clusters with attributed weight.
    // * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
    //   header in the request contains the target cluster.
    message DestinationCluster {
    }

    // The following descriptor entry is appended when a header contains a key that matches the
    // ``header_name``:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<header_value_queried_from_header>")
    message RequestHeaders {
      // The header name to be queried from the request headers. The header’s
      // value is used to populate the value of the descriptor entry for the
      // descriptor_key.
      string header_name = 1
          [(validate.rules).string = {min_len: 1 well_known_regex: HTTP_HEADER_NAME strict: false}];

      // The key to use in the descriptor entry.
      string descriptor_key = 2 [(validate.rules).string = {min_len: 1}];

      // If set to true, Envoy skips the descriptor while calling rate limiting service
      // when header is not present in the request. By default it skips calling the
      // rate limiting service if this header is not present in the request.
      bool skip_if_absent = 3;
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    //
    // .. code-block:: cpp
    //
    //   ("remote_address", "<trusted address from x-forwarded-for>")
    message RemoteAddress {
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // masked address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    //
    // .. code-block:: cpp
    //
    //   ("masked_remote_address", "<masked address from x-forwarded-for>")
    message MaskedRemoteAddress {
      // Length of prefix mask len for IPv4 (e.g. 0, 32).
      // Defaults to 32 when unset.
      // For example, trusted address from x-forwarded-for is ``192.168.1.1``,
      // the descriptor entry is ("masked_remote_address", "192.168.1.1/32");
      // if mask len is 24, the descriptor entry is ("masked_remote_address", "192.168.1.0/24").
      google.protobuf.UInt32Value v4_prefix_mask_len = 1 [(validate.rules).uint32 = {lte: 32}];

      // Length of prefix mask len for IPv6 (e.g. 0, 128).
      // Defaults to 128 when unset.
      // For example, trusted address from x-forwarded-for is ``2001:abcd:ef01:2345:6789:abcd:ef01:234``,
      // the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345:6789:abcd:ef01:234/128");
      // if mask len is 64, the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345::/64").
      google.protobuf.UInt32Value v6_prefix_mask_len = 2 [(validate.rules).uint32 = {lte: 128}];
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("generic_key", "<descriptor_value>")
    message GenericKey {
      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // An optional key to use in the descriptor entry. If not set it defaults
      // to 'generic_key' as the descriptor key.
      string descriptor_key = 2;
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("header_match", "<descriptor_value>")
    message HeaderValueMatch {
      // The key to use in the descriptor entry. Defaults to ``header_match``.
      string descriptor_key = 4;

      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // If set to true, the action will append a descriptor entry when the
      // request matches the headers. If set to false, the action will append a
      // descriptor entry when the request does not match the headers. The
      // default value is true.
      google.protobuf.BoolValue expect_match = 2;

      // Specifies a set of headers that the rate limit action should match
      // on. The action will check the request’s headers against all the
      // specified headers in the config. A match will happen if all the
      // headers in the config are present in the request with the same values
      // (or based on presence if the value field is not in the config).
      repeated config.route.v3.HeaderMatcher headers = 3
          [(validate.rules).repeated = {min_items: 1}];
    }

    // The following descriptor entry is appended when the metadata contains a key value:
    //
    // .. code-block:: cpp
    //
    //   ("<descriptor_key>", "<value_queried_from_metadata>")
    // [#next-free-field: 6]
    message MetaData {
      enum Source {
        // Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
        DYNAMIC = 0;

        // Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
        ROUTE_ENTRY = 1;
      }

      // The key to use in the descriptor entry.
      string descriptor_key = 1 [(validate.rules).string = {min_len: 1}];

      // Metadata struct that defines the key and path to retrieve the string value. A match will
      // only happen if the value in the metadata is of type string.
      type.metadata.v3.MetadataKey metadata_key = 2 [(validate.rules).message = {required: true}];

      // An optional value to use if ``metadata_key`` is empty. If not set and
      // no value is present under the metadata_key then ``skip_if_absent`` is followed to
      // skip calling the rate limiting service or skip the descriptor.
      string default_value = 3;

      // Source of metadata
      Source source = 4 [(validate.rules).enum = {defined_only: true}];

      // If set to true, Envoy skips the descriptor while calling rate limiting service
      // when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
      // rate limiting service in that case.
      bool skip_if_absent = 5;
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // .. code-block:: cpp
    //
    //   ("query_match", "<descriptor_value>")
    message QueryParameterValueMatch {
      // The key to use in the descriptor entry. Defaults to ``query_match``.
      string descriptor_key = 4;

      // The value to use in the descriptor entry.
      string descriptor_value = 1 [(validate.rules).string = {min_len: 1}];

      // If set to true, the action will append a descriptor entry when the
      // request matches the headers. If set to false, the action will append a
      // descriptor entry when the request does not match the headers. The
      // default value is true.
      google.protobuf.BoolValue expect_match = 2;

      // Specifies a set of query parameters that the rate limit action should match
      // on. The action will check the request’s query parameters against all the
      // specified query parameters in the config. A match will happen if all the
      // query parameters in the config are present in the request with the same values
      // (or based on presence if the value field is not in the config).
      repeated config.route.v3.QueryParameterMatcher query_parameters = 3
          [(validate.rules).repeated = {min_items: 1}];
    }

    oneof action_specifier {
      option (validate.required) = true;

      // Rate limit on source cluster.
      SourceCluster source_cluster = 1;

      // Rate limit on destination cluster.
      DestinationCluster destination_cluster = 2;

      // Rate limit on request headers.
      RequestHeaders request_headers = 3;

      // Rate limit on remote address.
      RemoteAddress remote_address = 4;

      // Rate limit on a generic key.
      GenericKey generic_key = 5;

      // Rate limit on the existence of request headers.
      HeaderValueMatch header_value_match = 6;

      // Rate limit on metadata.
      MetaData metadata = 7;

      // Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
      //
      // :ref:`HTTP matching input functions <arch_overview_matching_api>` are
      // permitted as descriptor extensions. The input functions are only
      // looked up if there is no rate limit descriptor extension matching
      // the type URL.
      //
      // [#extension-category: envoy.rate_limit_descriptors]
      config.core.v3.TypedExtensionConfig extension = 8;

      // Rate limit on masked remote address.
      MaskedRemoteAddress masked_remote_address = 9;

      // Rate limit on the existence of query parameters.
      QueryParameterValueMatch query_parameter_value_match = 10;
    }
  }

  // A list of actions that are to be applied for this rate limit configuration.
  // Order matters as the actions are processed sequentially and the descriptor
  // is composed by appending descriptor entries in that sequence. If an action
  // cannot append a descriptor entry, no descriptor is generated for the
  // configuration. See :ref:`composing actions
  // <config_http_filters_rate_limit_composing_actions>` for additional documentation.
  repeated Action actions = 1 [(validate.rules).repeated = {min_items: 1}];
}
