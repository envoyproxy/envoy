syntax = "proto3";

package envoy.extensions.http.original_ip_detection.xff.v3;

import "envoy/config/core/v3/address.proto";

import "udpa/annotations/status.proto";

option java_package = "io.envoyproxy.envoy.extensions.http.original_ip_detection.xff.v3";
option java_outer_classname = "XffProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/http/original_ip_detection/xff/v3;xffv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: XFF original IP detection extension]

// This extension allows for the original downstream remote IP to be detected
// by reading the :ref:`config_http_conn_man_headers_x-forwarded-for` header.
//
// [#extension: envoy.http.original_ip_detection.xff]
message XffConfig {
  // The number of additional ingress proxy hops from the right side of the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
  // determining the origin client's IP address. The default is zero if this option
  // is not specified. See the documentation for
  // :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
  //
  // Only one of ``xff_num_trusted_hops`` and ``xff_trusted_cidrs`` can be set.
  uint32 xff_num_trusted_hops = 1;

  // The `CIDR <https://tools.ietf.org/html/rfc4632>`_ ranges to trust when
  // evaluating the remote IP address to determine the origin client's IP address.
  // This is used instead of
  // :ref:`use_remote_address <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`.
  // When the remote IP address matches a trusted CIDR and the
  // :ref:`config_http_conn_man_headers_x-forwarded-for` header was sent, the last
  // IP address from ``x-forwarded-for`` is used as the original client address.
  // If no ``x-forwarded-for`` header was sent, the remote IP is considered the real IP.
  //
  // If ``recurse`` is set the :ref:`config_http_conn_man_headers_x-forwarded-for`
  // header is also evaluated against the trusted CIDR list, and the last non-trusted
  // address is used as the original client address. If all addresses in ``x-forwarded-for``
  // are within the trusted list, the first entry is used.
  //
  // This is typically used when requests are proxied by a
  // `CDN <https://en.wikipedia.org/wiki/Content_delivery_network>`_.
  //
  // Only one of ``xff_num_trusted_hops`` and ``xff_trusted_cidrs`` can be set.
  XffTrustedCidrs xff_trusted_cidrs = 2;

  // Whether to append the detected trusted client IP address to ``x-forwarded-for``.
  bool append_xff = 3;
}

message XffTrustedCidrs {
  // The list of `CIDRs <https://tools.ietf.org/html/rfc4632>`_ from which remote
  // connections are considered trusted.
  repeated config.core.v3.CidrRange cidrs = 1;

  // If ``true``, recurse backwards through the :ref:`config_http_conn_man_headers_x-forwarded-for`
  // HTTP header to find the first (from the right) non-trusted IP address. If all addresses
  // are trusted, the last (from the right) IP address is returned.
  // Otherwise the last address in ``x-forwarded-for`` is used.
  //
  // Whether or not to recurse depends on whether you trust the downstream proxy to have
  // validated all addresses in the list.
  // If you do not fully trust the downstream proxy you may not wish to recurse.
  //
  // Note: Use of this option is an ``N*M`` operation on every request, where ``N`` is
  // the number of trusted CIDRs and ``M`` is the number of entries in the XFF header.
  bool recurse = 2;
}
