syntax = "proto3";

package envoy.extensions.filters.network.ext_authz.v3;

import "envoy/config/core/v3/config_source.proto";
import "envoy/config/core/v3/grpc_service.proto";
import "envoy/type/matcher/v3/metadata.proto";

import "udpa/annotations/status.proto";
import "udpa/annotations/versioning.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.network.ext_authz.v3";
option java_outer_classname = "ExtAuthzProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/ext_authz/v3;ext_authzv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Network External Authorization ]
// The network layer external authorization service configuration
// :ref:`configuration overview <config_network_filters_ext_authz>`.
// [#extension: envoy.filters.network.ext_authz]

// External Authorization filter calls out to an external service over the
// gRPC Authorization API defined by
// :ref:`CheckRequest <envoy_v3_api_msg_service.auth.v3.CheckRequest>`.
// A failed check will cause this filter to close the TCP connection.
// [#next-free-field: 13]
message ExtAuthz {
  option (udpa.annotations.versioning).previous_message_type =
      "envoy.config.filter.network.ext_authz.v2.ExtAuthz";

  // The prefix to use when emitting statistics.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The external authorization gRPC service configuration.
  // The default timeout is set to 200ms by this filter.
  config.core.v3.GrpcService grpc_service = 2;

  // The filter's behaviour in case the external authorization service does
  // not respond back. When it is set to true, Envoy will also allow traffic in case of
  // communication failure between authorization service and the proxy.
  // Defaults to false.
  bool failure_mode_allow = 3;

  // Specifies if the peer certificate is sent to the external service.
  //
  // When this field is true, Envoy will include the peer X.509 certificate, if available, in the
  // :ref:`certificate<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.certificate>`.
  bool include_peer_certificate = 4;

  // API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
  // version of Check{Request,Response} used on the wire.
  config.core.v3.ApiVersion transport_api_version = 5
      [(validate.rules).enum = {defined_only: true}];

  // Specifies if the filter is enabled with metadata matcher.
  // If this field is not specified, the filter will be enabled for all requests.
  type.matcher.v3.MetadataMatcher filter_enabled_metadata = 6;

  // Optional labels that will be passed to :ref:`labels<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.labels>` in
  // :ref:`destination<envoy_v3_api_field_service.auth.v3.AttributeContext.destination>`.
  // The labels will be read from :ref:`metadata<envoy_v3_api_msg_config.core.v3.Node>` with the specified key.
  string bootstrap_metadata_labels_key = 7;

  // Specifies if the TLS session level details like SNI are sent to the external service.
  //
  // When this field is true, Envoy will include the SNI name used for TLSClientHello, if available, in the
  // :ref:`tls_session<envoy_v3_api_field_service.auth.v3.AttributeContext.tls_session>`.
  bool include_tls_session = 8;

  // When set to ``true``, the filter will send a TLS ``access_denied(49)`` alert before closing
  // the connection when authorization is denied. This provides better visibility to TLS clients
  // about the reason for connection closure. This alert is only sent for TLS connections. The
  // non-TLS connections will be closed without sending an alert.
  //
  // Defaults to ``false``.
  bool send_tls_alert_on_denial = 9;

  // Specifies a list of metadata namespaces whose values, if present, will be passed to the
  // ext_authz service. The :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
  // is passed as an opaque ``protobuf::Struct``.
  //
  // For example, if the ``proxy_protocol`` listener filter is used and populates TLV metadata,
  // then the following will pass that metadata to the authorization server for making decisions
  // based on proxy protocol information.
  //
  // .. code-block:: yaml
  //
  //    metadata_context_namespaces:
  //    - envoy.filters.listener.proxy_protocol
  //
  repeated string metadata_context_namespaces = 10;

  // Specifies a list of metadata namespaces whose values, if present, will be passed to the
  // ext_authz service. :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
  // is passed as a ``protobuf::Any``.
  //
  // This works similarly to ``metadata_context_namespaces`` but allows Envoy and the ext_authz server to share
  // the protobuf message definition in order to perform safe parsing.
  //
  repeated string typed_metadata_context_namespaces = 11;

  // If set to ``true``, the filter will invoke the authorization check when the downstream transport
  // socket is ready (e.g., after the TLS handshake completes for TLS connections). This ensures
  // that connection information such as X.509 certificates and negotiated TLS parameters are
  // available for the authorization service.
  //
  // When enabled, the filter pauses the filter chain initialization. After the transport socket
  // raises a ``Connected`` event and authorization completes successfully, the filter would resume
  // the filter chain. This prevents downstream filters (such as
  // :ref:`tcp_proxy <config_network_filters_tcp_proxy>`) from establishing upstream connections
  // before authorization completes.
  //
  // For raw TCP connections that do not raise a ``Connected`` event, the filter automatically
  // falls back to invoking the authorization check when the first data byte arrives.
  //
  // When using this option with the :ref:`tcp_proxy <config_network_filters_tcp_proxy>` filter,
  // configure one of the following to ensure upstream connections are not established before
  // authorization completes:
  //
  // * Set :ref:`upstream_connect_mode
  //   <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.upstream_connect_mode>`
  //   to ``ON_DOWNSTREAM_DATA`` or ``ON_DOWNSTREAM_TLS_HANDSHAKE``.
  // * Set :ref:`max_early_data_bytes
  //   <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.max_early_data_bytes>`.
  //
  // Example configuration:
  //
  // .. code-block:: yaml
  //
  //    filter_chains:
  //    - filters:
  //      - name: envoy.filters.network.ext_authz
  //        typed_config:
  //          "@type": type.googleapis.com/envoy.extensions.filters.network.ext_authz.v3.ExtAuthz
  //          stat_prefix: ext_authz
  //          check_on_transport_ready: true
  //          grpc_service:
  //            envoy_grpc:
  //              cluster_name: ext_authz_server
  //      - name: envoy.filters.network.tcp_proxy
  //        typed_config:
  //          "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
  //          stat_prefix: tcp
  //          cluster: backend
  //          upstream_connect_mode: ON_DOWNSTREAM_TLS_HANDSHAKE
  //
  // .. attention::
  //
  //    Server-first protocols (e.g., SMTP, MySQL, POP3) require immediate upstream connection
  //    establishment. Do not use this option with server-first protocols as the upstream server
  //    needs to send data before receiving any data from the client.
  //
  // Defaults to ``false``.
  bool check_on_transport_ready = 12;
}
