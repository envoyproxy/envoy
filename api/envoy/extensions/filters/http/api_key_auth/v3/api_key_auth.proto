syntax = "proto3";

package envoy.extensions.filters.http.api_key_auth.v3;

import "xds/annotations/v3/status.proto";

import "udpa/annotations/sensitive.proto";
import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.api_key_auth.v3";
option java_outer_classname = "ApiKeyAuthProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/api_key_auth/v3;api_key_authv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#protodoc-title: APIKey Auth]
// APIKey Auth :ref:`configuration overview <config_http_filters_api_key_auth>`.
// [#extension: envoy.filters.http.api_key_auth]

// API Key HTTP authentication.
//
// Example:
//
// .. code-block:: yaml
//
//    authentication_header: "X-API-KEY"
//    credentials:
//      entries:
//      - key: 09876abcdefg
//        client: user
//    key_sources:
//      entries:
//      - header: "X-API-KEY"
//
message ApiKeyAuth {
  // The credentials that are used to authenticate the clients.
  Credentials credentials = 1 [(udpa.annotations.sensitive) = true];

  // The key sources to fetch the key from the coming request.
  KeySources key_sources = 2;
}

// API key auth configuration of per route or per virtual host or per route configuration.
message ApiKeyAuthPerRoute {
  // Route specific APIKeyAuth configuration. This is optional and could be used to override the
  // filter level ApiKeyAuth configuration **partly**.
  //
  // For example, if route specific ``authentication_header`` is set, then the filter will fetch
  // the key from route specific ``authentication_header``. But the filter level ``keys`` will
  // still be used. If route specific non-empty ``keys`` is set, then the filter will use the
  // route specific ``keys`` to authenticate the client but the filter level ``authentication_header``
  // will still be used. If both ``authentication_header`` and ``keys`` are set, then the filter
  // will use the route specific ``authentication_header`` and ``keys`` to authenticate the client.
  ApiKeyAuth override_config = 1;

  // A list of client ids that are allowed to access the routes of the scope. If the list is empty,
  // then all authenticated clients are allowed. This provides very limited but simple authorization.
  // If more complex authorization is required, then use the :ref:`HTTP RBAC filter
  // <config_http_filters_rbac>` instead.
  repeated string allowed_clients = 2;
}

// Single credential entry that contains the API key and the related client id.
message Credential {
  // The value of the unique API key.
  string key = 1 [(validate.rules).string = {min_len: 1}];

  // The unique id or identity that used to identify the client or consumer.
  string client = 2 [(validate.rules).string = {min_len: 1}];
}

// The credentials that are used to authenticate the clients.
message Credentials {
  // The list of credentials.
  repeated Credential entries = 1 [(validate.rules).repeated = {min_items: 1}];
}

message KeySource {
  // The header name to fetch the key. If multiple header values are present, the first one will be
  // used. If the header value starts with ``Bearer ``, this prefix will be stripped to get the
  // key value.
  //
  // If set, takes precedence over ``query`` and ``cookie``.
  string header = 1
      [(validate.rules).string =
           {max_len: 1024 well_known_regex: HTTP_HEADER_NAME strict: false ignore_empty: true}];

  // The query parameter name to fetch the key. If multiple query values are present, the first one
  // will be used.
  //
  // Only makes sense if ``header`` is not set. If set, takes precedence over ``cookie``.
  string query = 2 [(validate.rules).string = {max_len: 1024}];

  // The cookie name to fetch the key.
  //
  // Only makes sense if the ``header`` and ``query`` are not set.
  string cookie = 3
      [(validate.rules).string =
           {max_len: 1024 well_known_regex: HTTP_HEADER_NAME strict: false ignore_empty: true}];
}

// The key sources to fetch the key from the coming request.
message KeySources {
  // The list of key sources. The order of the key sources is important and the filter will try to
  // fetch the key one by one from the key sources in the order they are defined. The first matched key source will be used (regardless of whether the credentials match or not).
  repeated KeySource entries = 1 [(validate.rules).repeated = {min_items: 1}];
}
