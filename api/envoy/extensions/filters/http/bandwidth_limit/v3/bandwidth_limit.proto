syntax = "proto3";

package envoy.extensions.filters.http.bandwidth_limit.v3;

import "envoy/config/core/v3/base.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.bandwidth_limit.v3";
option java_outer_classname = "BandwidthLimitProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/bandwidth_limit/v3;bandwidth_limitv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Bandwidth limit]
// Bandwidth limit :ref:`configuration overview <config_http_filters_bandwidth_limit>`.
// [#extension: envoy.filters.http.bandwidth_limit]

// [#next-free-field: 10]
message BandwidthLimit {
  // Defines the mode for the bandwidth limit filter.
  // Values represent bitmask.
  enum EnableMode {
    // Filter is disabled.
    DISABLED = 0;

    // Filter enabled only for incoming traffic.
    REQUEST = 1;

    // Filter enabled only for outgoing traffic.
    RESPONSE = 2;

    // Filter enabled for both incoming and outgoing traffic.
    REQUEST_AND_RESPONSE = 3;
  }

  message NamedBucketConfiguration {
    // The bucket name to have a custom configuration.
    string name = 1;

    // The limit supplied in KiB/s, shared between all requests using the named bucket.
    uint64 limit_kbps = 2 [(validate.rules).uint64 = {gte: 1}];

    // Optional fill interval in milliseconds for the token refills. Defaults to
    // inheriting the ``fill_interval`` value from the parent ``BandwidthLimit``.
    //
    // It must be at least 20ms to avoid too aggressive refills.
    google.protobuf.Duration fill_interval = 3 [(validate.rules).duration = {
      lte {seconds: 1}
      gte {nanos: 20000000}
    }];
  }

  message NamedBucketSelector {
    message ClientCnWithDefault {
      // The bucket name to use when no client CN is present (this name is not processed
      // by ``name_template``)
      //
      // If not set, an empty bucket name is used.
      //
      // This value also overrides ``stat_prefix`` from ``BandwidthLimit`` for the bucket.
      string default_bucket = 1;

      // Optional template for the bucket name, with ``{CN}`` representing the client
      // certificate name. If not set, behaves the same as if the template is just ``{CN}}``
      //
      // If set, must contain ``{CN}``.
      //
      // This value also overrides ``stat_prefix`` from ``BandwidthLimit`` for the bucket.
      string name_template = 2 [(validate.rules).string = {pattern: "|.*{CN}.*"}];
    }

    // Use the request's client CN as [part of] the bucket name.
    // Precisely one of ``client_cn_with_default`` or ``explicit_bucket`` must be set.
    ClientCnWithDefault client_cn_with_default = 1;

    // Use the shared bucket specified by ``explicit_bucket``. This can be used to make
    // multiple routes share a common token bucket.
    string explicit_bucket = 2;

    // Optional template for the stat prefix, with ``{BUCKET}`` representing the bucket
    // name. If not set, behaves the same as if the template is just ``{BUCKET}``.
    string stat_prefix_template = 3;

    // If true, and the selected named bucket does not already exist, create a new bucket
    // with the ``limit_kbps`` and ``fill_interval`` from the parent ``BandwidthLimit`` config.
    //
    // If false, and the selected named bucket does not exist, pass through without limiting.
    bool create_bucket_if_not_existing = 4;
  }

  // The human readable prefix to use when emitting stats.
  string stat_prefix = 1 [(validate.rules).string = {min_len: 1}];

  // The enable mode for the bandwidth limit filter.
  // Default is Disabled.
  EnableMode enable_mode = 2 [(validate.rules).enum = {defined_only: true}];

  // The limit supplied in KiB/s.
  //
  // .. note::
  //   It's fine for the limit to be unset for the global configuration since the bandwidth limit
  //   can be applied at a the virtual host or route level. Thus, the limit must be set for the
  //   per route configuration otherwise the config will be rejected.
  //
  // .. note::
  //   When using per route configuration, the limit becomes unique to that route.
  //
  google.protobuf.UInt64Value limit_kbps = 3 [(validate.rules).uint64 = {gte: 1}];

  // Optional Fill interval in milliseconds for the token refills. Defaults to 50ms.
  // It must be at least 20ms to avoid too aggressive refills.
  google.protobuf.Duration fill_interval = 4 [(validate.rules).duration = {
    lte {seconds: 1}
    gte {nanos: 20000000}
  }];

  // Runtime flag that controls whether the filter is enabled or not. If not specified, defaults
  // to enabled.
  config.core.v3.RuntimeFeatureFlag runtime_enabled = 5;

  // Enable response trailers.
  //
  // .. note::
  //
  //   If set true, the following 4 trailers will be added, prefixed by ``response_trailer_prefix``:
  //   * bandwidth-request-delay-ms: delay time in milliseconds it took for the request stream transfer including request body transfer time and the time added by the filter.
  //   * bandwidth-response-delay-ms: delay time in milliseconds it took for the response stream transfer including response body transfer time and the time added by the filter.
  //   * bandwidth-request-filter-delay-ms: delay time in milliseconds in request stream transfer added by the filter.
  //   * bandwidth-response-filter-delay-ms: delay time in milliseconds that added by the filter.
  //   If :ref:`enable_mode <envoy_v3_api_field_extensions.filters.http.bandwidth_limit.v3.BandwidthLimit.enable_mode>` is ``DISABLED`` or ``REQUEST``, the trailers will not be set.
  //   If both the request and response delay time is 0, the trailers will not be set.
  //
  bool enable_response_trailers = 6;

  // Optional The prefix for the response trailers.
  string response_trailer_prefix = 7
      [(validate.rules).string = {well_known_regex: HTTP_HEADER_NAME strict: false}];

  // Use a named bucket that can be shared with other bandwidth limit configurations,
  // or with a per-request dynamic configuration, multiple buckets can be selected
  // from a single configuration.
  //
  // If this is set, it overrides ``stat_prefix``, and may override ``limit_kbps``
  // and ``fill_interval`` if the selected bucket has a ``named_bucket_configuration``.
  NamedBucketSelector named_bucket_selector = 8;

  // Bandwidth limit overrides for named buckets. These are configured at a global
  // scope, so can be configured once at the filter chain and used in per-route or
  // per-vhost configurations. Any named bucket that doesn't have an explicit
  // configuration will use the ``limit_kbps`` and ``fill_interval`` defined in
  // the configuration scope at which a request first uses that bucket.
  repeated NamedBucketConfiguration named_bucket_configurations = 9;
}
