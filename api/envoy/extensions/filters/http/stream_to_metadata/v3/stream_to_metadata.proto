syntax = "proto3";

package envoy.extensions.filters.http.stream_to_metadata.v3;

import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.filters.http.stream_to_metadata.v3";
option java_outer_classname = "StreamToMetadataProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/stream_to_metadata/v3;stream_to_metadatav3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Stream-To-Metadata Filter]
//
// The Stream-To-Metadata filter extracts values from streaming HTTP bodies
// and writes them to dynamic metadata. This is useful for rate limiting based on
// token usage, logging, and other observability use cases.
//
// Currently, the filter processes response bodies only and supports Server-Sent
// Events (SSE) format with JSON payloads. Future extensions may support additional
// formats and request body processing.
//
// [#extension: envoy.filters.http.stream_to_metadata]

// Stream-To-Metadata :ref:`configuration overview <config_http_filters_stream_to_metadata>`.
message StreamToMetadata {
  // Specifies the format of the streaming body.
  enum Format {
    // Server-Sent Events format (text/event-stream).
    // See: https://html.spec.whatwg.org/multipage/server-sent-events.html
    SERVER_SENT_EVENTS = 0;
  }

  // Value type for extracted metadata.
  enum ValueType {
    // The value is a serialized protobuf.Value.
    PROTOBUF_VALUE = 0;

    // String value.
    STRING = 1;

    // Number value.
    NUMBER = 2;
  }

  // Describes where to write a value in dynamic metadata.
  message MetadataDescriptor {
    // The namespace in dynamic metadata where the key-value pair will be written.
    // If empty, defaults to "envoy.filters.http.stream_to_metadata".
    string metadata_namespace = 1;

    // The key to use within the namespace.
    // This field is required.
    string key = 2 [(validate.rules).string = {min_len: 1}];

    // The value to pair with the given key.
    //
    // When used for ``on_present``, if value is set, it will be used instead
    // of the extracted value from the stream. If not set, the extracted value is used.
    //
    // When used for ``on_missing`` or ``on_error``, this field **must** be set
    // to provide a fallback value (enforced by validation).
    google.protobuf.Value value = 3;

    // The value's type which defaults to PROTOBUF_VALUE.
    // When value is not set: controls how the extracted value from the stream is converted.
    // When value is set: the hardcoded value is used as-is, type is ignored.
    ValueType type = 4 [(validate.rules).enum = {defined_only: true}];

    // If set to true, do not overwrite existing metadata value for this key.
    // If not set or set to false, overwrite existing values.
    // Default (not set) is false (overwrite existing values).
    google.protobuf.BoolValue preserve_existing_metadata_value = 5;
  }

  // Specifies a path to a value within a JSON object using a sequence of keys.
  // For example, to extract the value "42" from {"usage": {"total_tokens": 42}},
  // the path would be ["usage", "total_tokens"].
  message JsonPathSelector {
    // The sequence of keys to traverse in the JSON object.
    // For example: ["usage", "total_tokens"] will extract the value at
    // json_obj["usage"]["total_tokens"].
    repeated string path = 1 [(validate.rules).repeated = {min_items: 1}];
  }

  // Selector specifies how to extract a value from the stream payload.
  // Currently only json_path is supported. Future extensions may add additional
  // selector types. The json_path field must be set (validated in C++).
  message Selector {
    // Extract value using JSON path traversal.
    JsonPathSelector json_path = 1;
  }

  // A rule describes what value to extract from the stream and where to write it.
  message Rule {
    // Specifies how to extract the value from the stream payload.
    // For SSE format with JSON payloads, use json_path selector which is applied
    // to the JSON parsed from the "data" field of each event.
    Selector selector = 1 [(validate.rules).message = {required: true}];

    // Metadata to write when the selector successfully extracts a value.
    // If descriptor.value is set, writes that hardcoded value.
    // If descriptor.value is not set, writes the extracted value from the stream.
    repeated MetadataDescriptor on_present = 2;

    // Metadata to write when the selector path is not found in the parsed JSON.
    // Typically used with descriptor.value set to a fallback value.
    repeated MetadataDescriptor on_missing = 3;

    // Metadata to write when an error occurs during processing.
    // Errors include: JSON parse failure, no data field in SSE event, invalid content type.
    // Typically used with descriptor.value set to a fallback value.
    repeated MetadataDescriptor on_error = 4;

    // If true, stop processing the stream after this rule successfully matches (on_present executes).
    // This picks the FIRST occurrence and is efficient when you know the desired value
    // appears early in the stream or you don't need to wait for later values.
    // (e.g., extracting a model name that appears in the first SSE event).
    //
    // If false, continue processing the entire stream. Combined with
    // preserve_existing_metadata_value=false (default), later matches will overwrite
    // earlier ones, effectively picking the LAST occurrence.
    //
    // Note: on_missing and on_error do not trigger stop_processing_on_match.
    //
    // Default is false (process entire stream). Set to true for better performance
    // when you only need the first matching value.
    bool stop_processing_on_match = 5;
  }

  // Configuration for processing response streams.
  message ResponseRules {
    // The format of the streaming body.
    // Currently only Server-Sent Events (SSE) is supported.
    // Default is SERVER_SENT_EVENTS.
    Format format = 1 [(validate.rules).enum = {defined_only: true}];

    // The rules to apply for extracting values from the stream.
    // Rules are evaluated in order for each event/chunk.
    // At least one rule must be specified.
    repeated Rule rules = 2 [(validate.rules).repeated = {min_items: 1}];

    // Allowed content types for stream processing.
    // For SSE format, defaults to ["text/event-stream"].
    // Content-Type matching is performed on the media type (type/subtype) only,
    // ignoring parameters such as charset. For example, "text/event-stream; charset=utf-8"
    // will match "text/event-stream".
    repeated string allowed_content_types = 3;

    // Maximum size in bytes for a single event before it's considered invalid
    // and discarded. This protects against unbounded memory growth from malicious
    // or malformed streams that never send event delimiters (blank lines).
    //
    // For SSE format, this is the maximum size of a complete event (all lines
    // from one blank line to the next).
    //
    // Default is 8192 bytes (8KB), which is sufficient for most legitimate events.
    // Set to 0 to disable the limit (not recommended for production).
    // Maximum allowed value is 10485760 bytes (10MB).
    google.protobuf.UInt32Value max_event_size = 4 [(validate.rules).uint32 = {lte: 10485760}];
  }

  // Rules for processing response streams.
  // Currently, only response stream processing is implemented.
  ResponseRules response_rules = 1 [(validate.rules).message = {required: true}];
}
