syntax = "proto3";

package envoy.extensions.load_balancing_policies.random_subsetting.v3;

import "envoy/config/cluster/v3/cluster.proto";

import "google/protobuf/wrappers.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.random_subsetting.v3";
option java_outer_classname = "RandomSubsettingProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/random_subsetting/v3;random_subsettingv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Random Subsetting Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.random_subsetting]
// [#next-free-field: 3]

// Configuration for the Random Subsetting Load Balancing Policy
//
// This policy selects a subset of endpoints and passes them to the child LB policy.
// It maintains 2 important properties:
// 1. The policy tries to distribute connections among servers as equally as possible. The higher
// ``(N_clients*subset_size)/N_servers`` ratio is, the closer the resulting server connection
// distribution is to uniform.
// 2. The policy minimizes the amount of connection churn generated during server scale-ups by
// using rendezvous hashing
//
// See the :ref:`load balancing architecture
// overview<arch_overview_load_balancing_types>` for more information.
//
message RandomSubsetting {
  // subset_size indicates how many backends every client will be connected to.
  // The value must be greater than 0.
  google.protobuf.UInt32Value subset_size = 1 [(validate.rules).uint32 = {gt: 0}];

  // The config for the child policy.
  // The value is required.
  config.cluster.v3.LoadBalancingPolicy child_policy = 2
      [(validate.rules).message = {required: true}];
}
