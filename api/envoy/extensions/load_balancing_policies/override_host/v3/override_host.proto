syntax = "proto3";

package envoy.extensions.load_balancing_policies.override_host.v3;

import "envoy/config/cluster/v3/cluster.proto";
import "envoy/type/metadata/v3/metadata.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.load_balancing_policies.override_host.v3";
option java_outer_classname = "OverrideHostProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/load_balancing_policies/override_host/v3;override_hostv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Override Host Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.override_host]

// Configuration for the Override Host Load Balancing policy.
//
// This policy allows endpoint picking to be implemented in an external to Envoy
// component. While it can work with a built in HTTP filter it is primarily intended to
// work in conjunction with the ext_proc or WASM HTTP filters.
//
// The ext_proc or WASM filter must implement k8s proposal for AI gateway inferences extensions
// https://github.com/kubernetes-sigs/gateway-api-inference-extension/tree/main/docs/proposals/004-endpoint-picker-protocol
// to integrate with this load balancing policy.
//
// This policy uses selected endpoints from either request headers or request metadata.
//
// The endpoint picker protocol for k8s gateway inference extensions uses the
// ``x-gateway-destination-endpoint`` header for the primary endpoint. The value must contain a single ``IP:port`` token.
// For example ``10.0.0.5:8080`` or ``[2600:4040:5204::1574:24ae]:80``. The IPv6 address is enclosed in square brackets.
// Alternatively untyped request metadata under the ``envoy.lb`` key can be set to a ``protobuf.Struct``
// containing a string value under the ``x-gateway-destination-endpoint`` key. The value has the same
// format as the ``x-gateway-destination-endpoint`` header.
//
// If neither header nor metadata is present or there were errors parsing header or metadata values the
// specified fallback load balancing policy is used. This allows load balancing to degrade to a
// a built in policy (i.e. Round Robin) in case external endpoint picker fails.
//
// See the :ref:`load balancing architecture
// overview<arch_overview_load_balancing_types>` for more information.
//
message OverrideHost {
  message OverrideHostSource {
    // The header to get the override host addresses. One of the header or metadata field must be set.
    string header = 1
        [(validate.rules).string = {well_known_regex: HTTP_HEADER_VALUE strict: false}];

    // The metadata key to get the override host addresses from the request dynamic metadata. If
    // set this field then it will take precedence over the header field.
    // One of the header or metadata field must be set.
    type.metadata.v3.MetadataKey metadata = 2;
  }

  // A list of host sources to get the override host addresses from. The first one who provides
  // the addresses will be used, no matter if the addresses are valid or not. This ensure the first exist
  // addresses source will be used.
  repeated OverrideHostSource primary_host_sources = 1 [(validate.rules).repeated = {min_items: 1}];

  // A list of host sources to get the fallback host addresses from. The first one who provides
  // the addresses will be used, no matter if the addresses are valid or not.
  // [#not-implemented-hide:]
  repeated OverrideHostSource fallback_host_sources = 2;

  // The child LB policy to use in case neither header nor metadata with selected
  // hosts is present.
  config.cluster.v3.LoadBalancingPolicy fallback_picking_policy = 3
      [(validate.rules).message = {required: true}];
}
