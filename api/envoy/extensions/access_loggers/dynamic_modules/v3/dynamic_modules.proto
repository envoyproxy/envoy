syntax = "proto3";

package envoy.extensions.access_loggers.dynamic_modules.v3;

import "envoy/extensions/dynamic_modules/v3/dynamic_modules.proto";

import "google/protobuf/any.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.extensions.access_loggers.dynamic_modules.v3";
option java_outer_classname = "DynamicModulesProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/dynamic_modules/v3;dynamic_modulesv3";
option (udpa.annotations.file_status).package_version_status = ACTIVE;

// [#protodoc-title: Dynamic Modules Access Logger]
// [#extension: envoy.access_loggers.dynamic_modules]

// Configuration for the Dynamic Modules Access Logger. This logger allows loading shared object
// files via ``dlopen`` to implement custom access logging behavior.
//
// A module can be loaded by multiple access loggers; the module is loaded only once and shared
// across multiple logger instances.
//
// The access logger receives completed request information including request/response headers,
// stream info (timing, upstream info, response codes), and the log context type.
message DynamicModuleAccessLog {
  // Specifies the shared-object level configuration. This field is required.
  envoy.extensions.dynamic_modules.v3.DynamicModuleConfig dynamic_module_config = 1
      [(validate.rules).message = {required: true}];

  // The name for this logger configuration. If not specified, defaults to an empty string.
  //
  // This can be used to distinguish between different logger implementations inside a dynamic
  // module. For example, a module can have completely different logger implementations (e.g.,
  // file logger, gRPC logger, metrics logger). When Envoy receives this configuration, it passes
  // the ``logger_name`` to the dynamic module's access logger config init function together with
  // the ``logger_config``. That way a module can decide which in-module logger implementation to
  // use based on the name at load time.
  string logger_name = 2;

  // The configuration for the logger chosen by ``logger_name``. If not specified, an empty
  // configuration is passed to the module.
  //
  // This is passed to the module's access logger initialization function. Together with the
  // ``logger_name``, the module can decide which in-module logger implementation to use and
  // fine-tune the behavior of the logger.
  //
  // For example, if a module has two logger implementations, one for file output and one for
  // sending to an external service, ``logger_name`` is used to choose either file or external.
  // The ``logger_config`` can be used to configure file paths, service endpoints, batching
  // parameters, format strings, etc.
  //
  // ``google.protobuf.Struct`` is serialized as JSON before passing it to the module.
  // ``google.protobuf.BytesValue`` and ``google.protobuf.StringValue`` are passed directly
  // without the wrapper.
  //
  // .. code-block:: yaml
  //
  //  # Passing a JSON struct configuration
  //  logger_config:
  //    "@type": "type.googleapis.com/google.protobuf.Struct"
  //    value:
  //      output_path: "/var/log/envoy/access.log"
  //      format: "json"
  //      buffer_size: 1000
  //
  //  # Passing a simple string configuration
  //  logger_config:
  //    "@type": "type.googleapis.com/google.protobuf.StringValue"
  //    value: "/var/log/envoy/access.log"
  //
  google.protobuf.Any logger_config = 3;
}
