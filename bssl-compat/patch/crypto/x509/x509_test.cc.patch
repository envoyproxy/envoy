--- a/source/crypto/x509/x509_test.cc
+++ b/source/crypto/x509/x509_test.cc
@@ -1275,6 +1275,9 @@
           Verify(root_cross_signed.get(), {cross_signing_root.get()}, {},
                  /*crls=*/{}, /*flags=*/0, configure_callback));
 
+#ifdef BSSL_COMPAT // This next check fails for negative depths on OpenSSL
+      if (depth < 0) continue;
+#endif
       // An explicitly trusted self-signed certificate is unaffected by depth
       // checks.
       EXPECT_EQ(X509_V_OK,
@@ -1987,14 +1990,23 @@
 
     bssl::UniquePtr<NAME_CONSTRAINTS> nc(NAME_CONSTRAINTS_new());
     ASSERT_TRUE(nc);
-    nc->permittedSubtrees = sk_GENERAL_SUBTREE_new_null();
+#ifdef BSSL_COMPAT // FIXME: See StackTest.test4
+    nc->permittedSubtrees = reinterpret_cast<ossl_STACK_OF(ossl_GENERAL_SUBTREE)*>(sk_GENERAL_SUBTREE_new_null());
+#else
+     nc->permittedSubtrees = sk_GENERAL_SUBTREE_new_null();
+#endif
     ASSERT_TRUE(nc->permittedSubtrees);
     bssl::UniquePtr<GENERAL_SUBTREE> subtree(GENERAL_SUBTREE_new());
     ASSERT_TRUE(subtree);
     GENERAL_NAME_free(subtree->base);
     subtree->base = MakeGeneralName(t.type, t.constraint).release();
     ASSERT_TRUE(subtree->base);
-    ASSERT_TRUE(bssl::PushToStack(nc->permittedSubtrees, std::move(subtree)));
+#ifdef BSSL_COMPAT // FIXME:
+    ASSERT_TRUE(bssl::PushToStack(reinterpret_cast<STACK_OF(GENERAL_SUBTREE)*>(nc->permittedSubtrees), std::move(subtree)));
+#else
+     ASSERT_TRUE(bssl::PushToStack(nc->permittedSubtrees, std::move(subtree)));
+#endif
+
 
     bssl::UniquePtr<X509> root =
         MakeTestCert("Root", "Root", key.get(), /*is_ca=*/true);
@@ -2936,11 +2948,13 @@
   // |X509_check_purpose| with |X509_PURPOSE_ANY| and purpose -1 do not check
   // basicConstraints, but other purpose types do. (This is redundant with the
   // actual basicConstraints check, but |X509_check_purpose| is public API.)
+#ifndef BSSL_COMPAT
   EXPECT_TRUE(X509_check_purpose(intermediate.get(), -1, /*ca=*/1));
   EXPECT_TRUE(
       X509_check_purpose(intermediate.get(), X509_PURPOSE_ANY, /*ca=*/1));
   EXPECT_FALSE(X509_check_purpose(intermediate.get(), X509_PURPOSE_SSL_SERVER,
                                   /*ca=*/1));
+#endif // BSSL_COMPAT
 }
 
 TEST(X509Test, NoBasicConstraintsNetscapeCA) {
@@ -3767,6 +3781,7 @@
 t6uPxHrmpUY=
 -----END CERTIFICATE-----
 )";
+#ifndef BSSL_COMPAT
 static const char kP256InvalidParam[] = R"(
 -----BEGIN CERTIFICATE-----
 MIIBMTCBz6ADAgECAgIE0jATBggqhkjOPQQDAgQHZ2FyYmFnZTAPMQ0wCwYDVQQD
@@ -3778,6 +3793,7 @@
 fLULTZnynuQUULQkRcF7S7T2WpIL
 -----END CERTIFICATE-----
 )";
+#endif // BSSL_COMPAT
 static const char kRSANoParam[] = R"(
 -----BEGIN CERTIFICATE-----
 MIIBWzCBx6ADAgECAgIE0jALBgkqhkiG9w0BAQswDzENMAsGA1UEAxMEVGVzdDAg
@@ -3802,6 +3818,7 @@
 SwmQUz4bRpckRBj+sIyp1We+pg==
 -----END CERTIFICATE-----
 )";
+#ifndef BSSL_COMPAT
 static const char kRSAInvalidParam[] = R"(
 -----BEGIN CERTIFICATE-----
 MIIBbTCB0KADAgECAgIE0jAUBgkqhkiG9w0BAQsEB2dhcmJhZ2UwDzENMAsGA1UE
@@ -3814,7 +3831,7 @@
 5OMNZ/ajVwOssw61GcAlScRqEHkZFBoGp7e+QpgB2tf9
 -----END CERTIFICATE-----
 )";
-
+#endif // BSSL_COMPAT
 TEST(X509Test, AlgorithmParameters) {
   // P-256 parameters should be omitted, but we accept NULL ones.
   bssl::UniquePtr<EVP_PKEY> key = PrivateKeyFromPEM(kP256Key);
@@ -3828,11 +3845,13 @@
   ASSERT_TRUE(cert);
   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
 
+#ifndef BSSL_COMPAT
   cert = CertFromPEM(kP256InvalidParam);
   ASSERT_TRUE(cert);
   EXPECT_FALSE(X509_verify(cert.get(), key.get()));
   EXPECT_TRUE(
       ErrorEquals(ERR_get_error(), ERR_LIB_X509, X509_R_INVALID_PARAMETER));
+#endif
 
   // RSA parameters should be NULL, but we accept omitted ones.
   key = PrivateKeyFromPEM(kRSAKey);
@@ -3846,11 +3865,13 @@
   ASSERT_TRUE(cert);
   EXPECT_TRUE(X509_verify(cert.get(), key.get()));
 
+#ifndef BSSL_COMPAT
   cert = CertFromPEM(kRSAInvalidParam);
   ASSERT_TRUE(cert);
   EXPECT_FALSE(X509_verify(cert.get(), key.get()));
   EXPECT_TRUE(
       ErrorEquals(ERR_get_error(), ERR_LIB_X509, X509_R_INVALID_PARAMETER));
+#endif
 }
 
 // TEST(X509Test, GeneralName)  {
